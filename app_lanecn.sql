-- phpMyAdmin SQL Dump
-- version 3.3.8.1
-- http://www.phpmyadmin.net
--
-- 主机: w.rdc.sae.sina.com.cn:3307
-- 生成日期: 2014 年 08 月 08 日 15:08
-- 服务器版本: 5.5.27
-- PHP 版本: 5.3.3

SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- 数据库: `app_lanecn`
--

-- --------------------------------------------------------

--
-- 表的结构 `admin_menu`
--

CREATE TABLE IF NOT EXISTS `admin_menu` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `pid` int(11) NOT NULL COMMENT '父类ID。0是顶级分类',
  `name` varchar(50) NOT NULL COMMENT '分类名称',
  `in_out` tinyint(4) NOT NULL COMMENT '1是站内链接，2是出站链接',
  `url` varchar(100) NOT NULL COMMENT '出站链接地址，in_out为2是生效',
  `class` varchar(50) NOT NULL COMMENT '站内链接，类名',
  `action` varchar(50) NOT NULL COMMENT '站内链接，方法名',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COMMENT='后台菜单分类' AUTO_INCREMENT=17 ;

--
-- 转存表中的数据 `admin_menu`
--

INSERT INTO `admin_menu` (`id`, `pid`, `name`, `in_out`, `url`, `class`, `action`) VALUES
(1, 0, '后台分类', 1, '', '', ''),
(2, 1, '添加分类', 1, '', 'adminmenu', 'add'),
(3, 1, '分类列表', 1, '', 'adminmenu', 'lists'),
(4, 0, '文章管理', 1, '', '', ''),
(5, 4, '发表文章', 1, '', 'article', 'add'),
(6, 4, '文章列表', 1, '', 'article', 'lists'),
(7, 0, '管理员管理', 1, '', '', ''),
(11, 10, '添加分类', 1, '', 'menu', 'add'),
(8, 7, '添加管理员', 1, '', 'admin', 'add'),
(9, 7, '管理员列表', 1, '', 'admin', 'lists'),
(10, 0, '前台分类', 1, '', '', ''),
(12, 10, '分类列表', 1, '', 'menu', 'lists'),
(13, 0, '友情链接', 1, '', '', ''),
(14, 13, '添加链接', 1, '', 'friendlink', 'add'),
(15, 13, '链接列表', 1, '', 'friendlink', 'lists'),
(16, 4, '评论管理', 1, '', 'article', 'lists_comment');

-- --------------------------------------------------------

--
-- 表的结构 `admin_user`
--

CREATE TABLE IF NOT EXISTS `admin_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(50) NOT NULL COMMENT '用户名',
  `password` varchar(32) NOT NULL COMMENT '密码',
  PRIMARY KEY (`id`),
  UNIQUE KEY `username` (`username`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COMMENT='管理员表' AUTO_INCREMENT=5 ;

--
-- 转存表中的数据 `admin_user`
--

INSERT INTO `admin_user` (`id`, `username`, `password`) VALUES
(1, 'lixuan', 'bc76daa40e91dbcfada67c7b02b77c08');

-- --------------------------------------------------------

--
-- 表的结构 `info_article`
--

CREATE TABLE IF NOT EXISTS `info_article` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '文章ID',
  `mid` int(11) NOT NULL COMMENT '所属分类ID',
  `author` varchar(50) NOT NULL COMMENT '作者',
  `title` varchar(100) NOT NULL COMMENT '文章标题',
  `description` varchar(500) NOT NULL COMMENT '文章描述摘要',
  `seo_title` varchar(100) NOT NULL COMMENT 'SEO - title',
  `seo_description` varchar(500) NOT NULL COMMENT 'SEO - description',
  `seo_keywords` varchar(200) NOT NULL COMMENT 'SEO - 关键词',
  `tag` varchar(100) NOT NULL COMMENT '标签',
  `clicks` int(11) NOT NULL COMMENT '点击次数',
  `content` text NOT NULL COMMENT '文章内容',
  `ctime` int(11) NOT NULL COMMENT '创建时间',
  `good_num` int(11) NOT NULL COMMENT '被赞的次数',
  `bad_num` int(11) NOT NULL COMMENT '被拍砖的次数',
  `recommend_type` tinyint(4) NOT NULL COMMENT '推荐类型，1是全站推荐，2是首页推荐',
  PRIMARY KEY (`id`),
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COMMENT='文章表' AUTO_INCREMENT=66 ;

--
-- 转存表中的数据 `info_article`
--

INSERT INTO `info_article` (`id`, `mid`, `author`, `title`, `description`, `seo_title`, `seo_description`, `seo_keywords`, `tag`, `clicks`, `content`, `ctime`, `good_num`, `bad_num`, `recommend_type`) VALUES
(3, 1, '李轩Lane', 'PHP实现网络刷投票', 'PHP实现网络刷投票，不断变化IP，刷票，刷投票。怒冲排行榜第一名。本文讲解PHP如何实现网络刷投票', 'PHP实现网络刷投票_刷投票_PHP刷票', 'PHP实现网络刷投票，不断变化IP，刷票，刷投票。怒冲排行榜第一名。本文讲解PHP如何实现网络刷投票', 'PHP实现网络刷投票_刷投票_PHP刷票', 'PHP|刷投票', 342, 'PHP刷投票，让你高居榜首！本文附上刷票方法和防御策略。\r\n案例为一个半月以前。没有及时放出原因有二，一是因为博客域名备案没有下来，没有心情写东西。二是最主要的，及时放出对案例网站有严重的损害，不是我等IT人应有的。\r\nPs：刷票有风险，使用需谨慎。本文谨做学习研究讨论之用，不可用作不正当用途！\r\n\r\n本文为本博客的处女之作，题材源于近日一朋友要求，是因为她的姐姐参加了一个书法比赛，问我能不能在网站上刷投票。作为刚刚出道一年的小菜鸟，我很惶恐。一年前刚刚接触PHP的时候，完全不知道做，现在第一反应就是Curl。\r\n\r\n废话不多说了，直接上代码。\r\n\r\n[code]\r\n&lt;?php\r\nheader(''Content-type: text/html; charset=gb2312'');\r\n//随机生成IP\r\n$ip1 = rand(101, 255).''.'';\r\n$ip2 = rand(1, 255).''.'';\r\n$ip3 = rand(1, 255).''.'';\r\n$ip4 = rand(1, 255);\r\n$ip = $ip1 . $ip2 . $ip3 . $ip4;\r\n$clientIp = ''CLIENT-IP:''.$ip;\r\n$xforwarded = ''X-FORWARDED-FOR:''.$ip;\r\n//设置目标和来源\r\n$url = ''http://www.dunhuangwomen.org.cn/vote/Vote.asp?id=67'';\r\n$referer = ''http://www.dunhuangwomen.org.cn/vote/list.asp?id=2'';\r\n//Curl\r\n$ch = curl_init();\r\ncurl_setopt($ch, CURLOPT_URL, $url); //目标\r\ncurl_setopt($ch, CURLOPT_HTTPHEADER, array($xforwarded, $clientIp));  //构造IP\r\ncurl_setopt($ch, CURLOPT_REFERER, $referer); //来源\r\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\r\ncurl_setopt($ch, CURLOPT_HEADER, 0);\r\n\r\n$ret = curl_exec($ch);\r\ncurl_close($ch);\r\necho $ret;\r\n?&gt;\r\n[/code]\r\n\r\n好，来分析一下。\r\n1、仿造IP，网站有限制一个IP在一天只可以投一次\r\n2、填写来源，网站会判断请求的来源是否合法路径\r\n其他就是Curl的常规了选项了。\r\n\r\n如何防治？\r\n\r\n本人才疏学浅，仅作跑砖引玉。\r\n\r\n1、限制IP\r\n    本文已经破解\r\n2、限制来源\r\n    本文已经破解\r\n3、验证码。作为最反人类的发明之一，可以使用这个拥有高大上的名字的全自动区分计算机和人类的图灵测试。\r\n    可用Opencv。\r\n4、记录MAC地址。\r\n    理论上每块网卡都有一个唯一的MAC地址，如果更改可能引起冲突而无法上网。目前也可以用软件修改\r\n5、注册会员\r\n    虽说仍然可以突破验证码，Curl填写参数然后POST过去，但是门槛毕竟高了一丁点，还是忽略吧。\r\n6、手机\r\n    投票时输入手机号和短信验证码，成本高，单位不愿意。用户发送某某指令到某某，用户自掏腰包，用户不愿意。\r\n\r\n目前来说，只有验证码，手机并且验证手机的有效性是最好的防治措施。', 1392015111, 31, 14, 0),
(5, 4, '李轩Lane', 'mysql多表随机查询优化方案', 'Mysql随机查询，使用子查询的来在记录中随机取出一条记录，使用MYSQL实现随机查询，多表随机查询和随机排序', 'mysql随机查询_mysql多表随机查询_mysql随机排序', 'Mysql随机查询，使用子查询的来在记录中随机取出一条记录，使用MYSQL实现随机查询，多表随机查询和随机排序', 'mysql随机查询,mysql多表随机查询,mysql随机排序', 'MYSQL|随机查询', 453, '本文主要谈论如何实现Mysql的随机查询，多表随机查询。在Mysql中随机取出一条记录的实现方法。\r\n我们通常的查询是没有where或者where fields&gt;2这样的方式，这样只能取出在某种条件下的一条或多条，如果条件不变（例如2），那么结果就一直不会有变化。\r\n那么如何实现随机查询呢？本人有两种方法。\r\n\r\n方法一、数据表记录不大的情况下：\r\n[code]\r\nselect * from `table`\r\n[/code]\r\n查出来所有的记录列表，然后array_rand()随机出一个结果的数组的key。连续的key可以使用mt_rand(1, count($list)); 为什么不使用rand而是mt_rand呢？因为mt_rand币rand快4倍。\r\n  这种情况下，查出整个列表，存入到Memcache的缓存或者Redis的NoSQL中，下次直接取出结果集而不需要查表。不过当数据量一旦超过万级别，取出列表就很困难了。\r\n\r\n方法二：使用SQL语句随机\r\nMYSQL函数RAND()，产生一个0-1之间的小数，然后MAX(`id`)可以获得该表中最大的ID。那么MAX(`id`) * RAND()就可以取到表中所有的ID。OK，看语句。\r\n[code]\r\nSELECT * FROM `table` WHERE `id` &gt; (SELECT RAND() * (SELECT MAX(`id`) FROM `table`) LIMIT 0, 1\r\n[/code]\r\n既然MAX（`id`) * MAX(`id`)可以取到表里所有值，那么本语句的WHERE就可以取到本表的所有情况，那么这就是一个所有记录都有可能被取到的随机SQL语句。', 1392889206, 27, 19, 2),
(6, 5, '李轩Lane', 'Ubuntu下安装Linux+Apache+Mysql+PHP', 'Ubuntu下安装Linux+Apache+Mysql+PHP的LAMP四大组建，Ubuntu安装LAMP,Linux安装LAMP的方法，请看本文的。本文以Ubuntu下安装Lamp为例', 'Ubuntu下安装Linux+Apache+Mysql+PHP_Ubuntu安装LAMP_Linux安装LAMP', 'Ubuntu下安装Linux+Apache+Mysql+PHP的LAMP四大组建，Ubuntu安装LAMP,Linux安装LAMP的方法，请看本文的。本文以Ubuntu下安装Lamp为例', 'Ubuntu下安装Linux+Apache+Mysql+PHP,Ubuntu安装LAMP,Linux安装LAMP', 'Linux|LAMP|Ubuntu', 68, '本文以Ubuntu为例，讲解Linux下如何安装Linux、Apache、Mysql、PHP的LAMP架构。可用于Ubuntu和CentOS系列。\r\n  1、安装Apache，Mysql，PHP，在安装Mysql的时候会要求建立管理员帐号和密码：\r\n[code]\r\nsudo apt-get install php5 apache2 mysql-client mysql-server \r\n[/code] \r\n\r\n2、安装PHP的扩展。如php中的mysql，GD库，CURL等。这样才可以使用GD库做图，mysql扩展，CURL扩展等功能\r\n[code]\r\nsudo apt-get install php5-mysql php5-gd php5-curl \r\n[/code]\r\n\r\n3、修改目录权限，为方便此时测试，暂且修改为777，也就是drwxrwxrwx。在实际中，777可是非常危险的哦。一般apache的项目根目录在/var/www\r\n[code]\r\ncd /var/www\r\nsudo chmod 777 /var/www/\r\n[/code]\r\n\r\n4、安装PHPMyAdmin，安装时会要求选择服务器端软件，选择Apache就好了。还会要求你输入Mysql的帐号和密码。这个帐号和密码是在第一步安装的时候就有提示的。\r\n[code]\r\nsudo apt-get install phpmyadmin\r\n[/code]\r\n\r\n5、为PHPMyAdmin建立软链接，放在/var/www下，这样可以直接通过localhost/phpmyadmin来访问了。\r\n[code]\r\nsudo ln -s /usr/share/phpmyadmin /var/www\r\n[/code]\r\n\r\n重启Apache是/etc/init.d/apache2 restart或者service apache2 restart\r\n\r\nOK,安装好了。自己在/var/www建立index.php吧\r\n[code]\r\ncd /var/www\r\ntouch index.php\r\nvim index.php\r\n&lt;?php \r\necho ''hello wordl'';\r\n?&gt;\r\ntouch phpinfo.php\r\nvim phpinfo.php\r\n&lt;?php\r\nphpinfo();\r\n?&gt;\r\n[/code]\r\n\r\n好了。自行玩吧～', 1392943862, 4, 5, 0),
(7, 1, '李轩Lane', 'PHP 时间种子 批量 随机数', 'PHP时间种子批量随机数。以变化的参数“时间”为种子，批量生成随机数。可以用在激活码，CDK，邀请码，活动期间限量的唯一电子券等情景，先生成十万条来玩玩吧。', 'PHP时间种子批量随机数_PHP如何用时间种子批量生成随机数', 'PHP时间种子批量随机数，本文说明PHP如何用时间种子批量生成随机数。', 'PHP时间种子批量随机数,本文说明PHP如何用时间种子批量生成随机数。', 'PHP|随机数|时间种子', 175, 'PHP时间种子批量随机数。本文说明PHP如何用时间种子批量生成随机数。\r\nPHP函数mt_rand()和rand()会在批量生成的时候是会有几率出现重复的随机数。srand()和mt_srand()在PHP4.1开始已经不在显式调用了，在mt_rand和rand的时候会自动生成种子。因为，在批量随机的时候，我们自己显式条用生成种子，就可以避免重复。为什么呢？因为种子不一样了呀。种子为什么不一样了呢？因为他是时间种子。\r\n[code]\r\n&lt;?php\r\n//存储生存的随机数\r\n$randArr = array();\r\n//生成十万个吧\r\nfor($i=0;$i&lt;100000;$i++){\r\n    //生成种子\r\n    $date = explode('' '', microtime());\r\n    $seed = $date[0];\r\n    //种子发生器\r\n    mt_srand($seed);\r\n    //生成随机数\r\n    $randArr[] = mt_rand();\r\n}\r\n?&gt;\r\n[/code]\r\n随机数生成了。并且不会重复的哦。以时间为种子的好处就是省略了在普通的伪随机数会出现重复的情况时进行do{生成随机数code}while(!isset(新生成的一个随机数))的判断步骤。', 1394162554, 73, 20, 0),
(8, 1, '李轩Lane', 'PHP面试题，PHP笔试题（一）', 'PHP面试题、PHP笔试题、PHP基础题和PHP练习题的集合，第一篇。有意思的小题目，来练练手吧。这类题目都是对基础考查。', 'PHP面试题_PHP笔试题_PHP练习题', 'PHP面试题、PHP笔试题和PHP练习题的集合，第一篇。有意思的小题目，来练练手吧', 'PHP面试题,PHP笔试题,PHP练习题', 'PHP|面试题|笔试题', 315, '题目一：\r\n[code]\r\n&lt;?php\r\necho -10%3;\r\n?&gt;\r\n[/code]\r\n答案：-1。\r\n考查：优先级。\r\n因为-的优先级比%求余的优先级低，也就是-(10%3)。\r\n\r\n题目二：\r\n[code]\r\nprint (int)pow(2,32);\r\n[/code]\r\n答案：0\r\n\r\n题目三：\r\n[code]\r\n//file1.php\r\n&lt;?php\r\n$a = ''123'';\r\n?&gt;\r\n//file2.php\r\n&lt;?php\r\necho include(''file1.php'');\r\n?&gt;\r\n[/code]\r\n答案：1.\r\n考查：返回值。\r\n因include()也是一个函数，有返回值。在成功时返回1，失败时返回错误信息。如果被包含的文件有return，则inculde()成功时返回该文件的返回值。\r\n\r\n题目四：\r\n[code]\r\n&lt;?php\r\n$count = 5;\r\nfunction get_count() {\r\n    static $count = 0;\r\n    return $count++;\r\n}\r\n++$count;\r\nget_count();\r\necho get_count();\r\n?&gt;\r\n[/code]\r\n答案：1.\r\n考查：static和++。\r\n因static $count，所以只在第一次调用get_count的时候对$count赋值为0，第二次再进来这个函数，则不会第二次赋值。其次就是return $count++和return ++$count了，前者先返回，后者先++再返回。\r\n\r\n题目五：\r\n[code]\r\n&lt;?php\r\n$arr = array(0 =&gt;1,''aa'' =&gt; 2,3,4);\r\nforeach($arr as $key =&gt; $val){\r\n    print($key == ''aa'' ? 5 : $val);\r\n}\r\n?&gt;\r\n[/code]\r\n答案：5534.\r\n考查：类型转换。\r\n因遍历数组第一次的时候，$key和aa的比较实际就是0和aa的比较，一个是int一个是string，这个时候会转换类型，将字符串转换为数字再与数字比较。所以0==''aa''就是0==0，所以为true，也就是输出5。虽然PHP是若类型语言，但是人家也有类型的好吗。\r\n\r\n\r\n题目六：\r\n[code]\r\n&lt;?php\r\necho count (false);\r\n$a = count (&quot;567&quot;)  + count(null) + count(false);\r\necho $a;\r\n?&gt;\r\n[/code]\r\n答案：2.\r\n考查：count的用法。\r\n因count()的官方解释“If the parameter is not an array or not an object with implemented Countable interface, 1 will be returned.”.意思是说，如果不是数组或者对象的其他类型，返回1.那么这个值应该就是1+0+1了（boolen人家也是一个类型，虽然是讨厌的false）。NULL的意思是没有值，难道在计数函数中还能有1？\r\n\r\n题目七：\r\n[code]\r\n&lt;?php\r\n$arr = array(1,2,3);\r\nforeach($arr as &amp;$val) {\r\n    $val += $val % 2 ? $val++ : $val--;\r\n}\r\n$val = 0;\r\nprint(join('''',$arr));\r\n?&gt;\r\n[/code]\r\n答案：330。\r\n考查：++和&amp;。\r\n因foreach结束后的数组应该是array(3,3,7);最后给第三个元素赋值为0，所以就是330了。其中注意的是&amp;，如果有&amp;则是对原变量操作，如果没有，则是先生成一个新变量，然后给这个变量复制，最后操作的是这个新变量。\r\n\r\n题目八：\r\n[code]\r\n&lt;?php\r\necho intval((0.1+0.7)*10);\r\n?&gt;\r\n[/code]\r\n答案：7。\r\n考查：浮点数的概念。\r\n因0.1+0.7=0.8    0.8*10=8  所以转换成整数后还是8？错！因为0.1+0.7=0.8是浮点数，0.8*10在数学计算中是正整数8，可是在计算机中它仍然是浮点数8，什么叫浮点数8？每一个看起来像整数的浮点数，其实都不是整数，比如这个8，它其实只是7.9999循环，无限接近于8，转换成整数会舍弃小数部分，就是7喽。\r\n\r\n题目九：\r\n[code]\r\n&lt;?php\r\nini_set(''display_errors'',0);\r\n$arr = array(1=&gt;1,3=&gt;3);\r\n$i = 2;\r\n$a = ''test'' . isset($arr[$i]) ? $arr[$i] : $i;\r\n请问$a的值是什么？\r\nA、test B、NULL C、2 D、test2\r\n?&gt;\r\n[/code]\r\n答案：B。\r\n考查：优先级。\r\n因“.&quot;的优先级高于三元运算符&quot;?:&quot;。所以程序其实报错了。会说$arr的索引2不存在。\r\n\r\n题目十：\r\n[code]\r\n&lt;?php\r\n$a = 3;\r\n$b = 5;\r\nif($a = 5 || $b = 7) {\r\n    $a++;\r\n    $b++;\r\n}\r\necho $a . &quot; &quot; . $b;\r\n?&gt;\r\nA、6 8  B、6 6  C、2 6  D、1 6  E、4 6\r\n[/code]\r\n答案：D。\r\n考查：优先级，基础概念，++。\r\n因“=&quot;的优先级低于“||”，所以先逻辑判断再赋值。也就是($a = (5 || $b = 7))。所以，最后其实给a赋值了，$a等于1.\r\n\r\n题目十一：\r\n[code]\r\n&lt;?php\r\n$x = 2;\r\necho $x == 2 ? ''我'' : $x == 1 ? ''你'' : ''它'';\r\n?&gt;\r\n输出的结果是（）\r\nA、我\r\nB、你\r\nC、它\r\nD、syntax error\r\n[/code]\r\n答案：B。\r\n考查：优先级。\r\n因“==&quot;的优先级高于“?:”。我已经不想说为什么了，整理一下这种东西，我感觉要疯了，除了笔试题外估计也不会遇到了吧。', 1394175615, 33, 19, 0),
(9, 5, '李轩Lane', 'Fedora20安装VirtualBox_Fedora20_VirtualBox', 'Fedora20安装VirtualBox虚拟机的方法。其实是非常狗血的一个剧情。你们肯定想不到我是如何解决的。安装时大范围的报错，被告知缺少库文件。', 'Fedora20安装VirtualBox_Fedora20安装VBOX_Fedora20安装虚拟机', '本文讲解Fedora20安装VirtualBox，Fedora20安装VBOX和Fedora20安装虚拟机的方法。其实是非常狗血的一个剧情。你们肯定想不到我是如何解决的', 'Fedora20安装VirtualBox,Fedora20安装VBOX,Fedora20安装虚拟机', 'Fedora|VirtualBox|vbox', 110, '由于我的Ubuntu实在用这不爽，作为Linux新手我完全不能应对Ubuntu的各种报错，比如今天图形界面的关机按钮没有了，明天图形界面的时间没有了，后天图形界面的输入法不显示了。之前用过几天的Fedora，感觉界面比较炫。\r\n在Fedora 20 安装VirtualBox的时候发生了些小意外。\r\n第一步、下载Vbox。上官网，下对应自己系统的版本。\r\n[code]\r\nsudo rpm -i VirtualBox-4.3-4.3.8_92456_fedora18-1.i686.rpm\r\n[/code]\r\n然后。让我头疼的事情来了。\r\n[code]\r\n警告：VirtualBox-4.3-4.3.8_92456_fedora18-1.i686.rpm: 头V4 DSA/SHA1 Signature, 密钥 ID 98ab5139: NOKEY\r\n错误：依赖检测失败：\r\n	libGL.so.1 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libQtCore.so.4 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libQtGui.so.4 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libQtNetwork.so.4 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libQtOpenGL.so.4 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libSDL-1.2.so.0 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libX11.so.6 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libXcursor.so.1 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libXext.so.6 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libXinerama.so.1 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libXmu.so.6 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libXt.so.6 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libasound.so.2 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libc.so.6 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libc.so.6(GLIBC_2.0) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libc.so.6(GLIBC_2.1) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libc.so.6(GLIBC_2.1.1) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libc.so.6(GLIBC_2.1.2) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libc.so.6(GLIBC_2.1.3) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libc.so.6(GLIBC_2.15) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libc.so.6(GLIBC_2.2) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libc.so.6(GLIBC_2.2.3) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libc.so.6(GLIBC_2.3) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libc.so.6(GLIBC_2.3.2) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libc.so.6(GLIBC_2.4) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libcrypt.so.1 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libcrypt.so.1(GLIBC_2.0) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libcrypto.so.10 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libcrypto.so.10(libcrypto.so.10) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libcurl.so.4 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libdevmapper.so.1.02 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libdevmapper.so.1.02(Base) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libdl.so.2 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libdl.so.2(GLIBC_2.0) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libdl.so.2(GLIBC_2.1) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libgcc_s.so.1 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libgcc_s.so.1(GCC_3.0) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libgcc_s.so.1(GLIBC_2.0) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libm.so.6 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libm.so.6(GLIBC_2.0) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libm.so.6(GLIBC_2.1) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libpng15.so.15 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libpng15.so.15(PNG15_0) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libpthread.so.0 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libpthread.so.0(GLIBC_2.0) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libpthread.so.0(GLIBC_2.1) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libpthread.so.0(GLIBC_2.2) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libpthread.so.0(GLIBC_2.3.2) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libpthread.so.0(GLIBC_2.3.3) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libpthread.so.0(GLIBC_2.3.4) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libpython2.7.so.1.0 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	librt.so.1 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	librt.so.1(GLIBC_2.2) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libssl.so.10 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libssl.so.10(libssl.so.10) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libstdc++.so.6 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libstdc++.so.6(CXXABI_1.3) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libstdc++.so.6(CXXABI_1.3.1) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libstdc++.so.6(GLIBCXX_3.4) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libstdc++.so.6(GLIBCXX_3.4.11) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libstdc++.so.6(GLIBCXX_3.4.15) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libstdc++.so.6(GLIBCXX_3.4.9) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libvpx.so.1 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libxml2.so.2 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libxml2.so.2(LIBXML2_2.4.30) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libxml2.so.2(LIBXML2_2.6.0) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libxml2.so.2(LIBXML2_2.6.8) 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n	libz.so.1 被 VirtualBox-4.3-4.3.8_92456_fedora18-1.i686 需要\r\n[/code]\r\n我去年买了个表啊！！！这么多的库文件却是难道要我一个一个手打安装？？？？\r\n各种Baidu\\Google。然后。被我发现了一个好发方法。。\r\n双击打开！！\r\n然后他会自己安装这些关联关系的软件包。\r\n\r\n是不是要喷？开头我就说了很狗血的～\r\n\r\n-------------我是分割线------------------------\r\n\r\n安装完成，打开。报错\r\n不能为虚拟电脑 XP 打开一个新任务.\r\nThe virtual machine ''XP'' has terminated unexpectedly during startup with exit code 1.\r\n\r\n\r\n\r\nRTR3InitEx failed with rc=-1912 (rc=-1912)\r\n\r\nThe VirtualBox kernel modules do not match this version of VirtualBox. The installation of VirtualBox was apparently not successful. Executing\r\n\r\n''/etc/init.d/vboxdrv setup''\r\n\r\nmay correct this. Make sure that you do not mix the OSE version and the PUEL version of VirtualBox.\r\n\r\n按照提示输入/etc/init.d/vboxdrv setup都提示OK了也没有用啊。\r\n搜索的解决方法\r\n[code]\r\nsudo yum install kernel-devel\r\nsudo yum install gcc\r\nsudo /etc/init.d/vboxdrv setup\r\n[/code]\r\n再次打开，还是不可以，报同样的错。\r\n\r\n继续搜索～\r\n来了个狠的，更新系统\r\n[code]\r\nsudo yum -y update\r\nsudo /etc/init.d/vboxdrv setup\r\n[/code]\r\nStopping VirtualBox kernel modules                         [  OK  ]\r\nUninstalling old VirtualBox DKMS kernel modules            [  OK  ]\r\nRemoving old VirtualBox kernel module                      [  OK  ]\r\nTrying to register the VirtualBox kernel modules using DKMS[  OK  ]\r\nStarting VirtualBox kernel modules                         [  OK  ]\r\n好了。可以了哦', 1394413713, 9, 10, 0),
(10, 7, '李轩Lane', 'Fedora20_VirtualBox4.3虚拟机安装windows XP', 'Fedora20下VirtualBox4.3虚拟机安装windows XP，遇到的问题以及如何解决的。主要是BIOS的信息读取错误时如何安装。', 'Fedora20下VirtualBox4.3虚拟机安装windows XP_vbox安装xp_virtualbox安装xp', 'Fedora20下VirtualBox4.3虚拟机安装windows XP，遇到的问题以及如何解决的。', 'Fedora20下VirtualBox4.3虚拟机安装windows XP,vbox安装xp,virtualbox安装xp', 'VirtualBox|XP|虚拟机', 53, '本文前提是安装好Virtual4.3。在Fedora下如何安装请点击http://www.lanecn.com/article/main/aid-9查看。 \r\n打开软件，点击新建。输入一个名字，随便写，自己能认就OK。按照系统默认的选项一直下一步。一直创建完成。选中创建的项目后点击上方的显示。选择一个ISO镜像文件。（XP，WIN7，老毛桃，深度，雨林木风等）。\r\n现在虚拟机就开始开机了。\r\n安装和正常是一样的。\r\n本文主要说遇到如下错误：\r\nUIDE,01-15-2008 80-MB cache,CD/DVD name is mscd001\r\nIDE1 controller at IO address Fgooh ,chip I.D.1002438ch\r\nIDE2 controller at IO address Fbooh ,chip I.D.10024380h\r\nIDE2 secondary-slave disk is WDC WD 1600AAjs-22psao,ata-133\r\nCD:IDE1 primary-master, teclast DHB16H,ATA-33.\r\n\r\n解决方案：\r\n1、对虚拟磁盘分区。\r\n2、进入winPE。\r\n3、GHOST。\r\n4、一般下载的IOS镜像里有GHO文件。可以直接用来GHOST.\r\n从PE安装就不会有上面的提示。', 1394428722, 4, 4, 0),
(11, 1, '李轩Lane', '本博客PHP源码下载，基于自己开发的超轻量级的PHP框架', '本博客源码下载，基于自己开发的超轻量级的框架。PHP博客源码下载。对SEO超级友好。', '博客源码_博客源码下载_PHP博客源码下载', '本博客源码下载，基于自己开发的超轻量级的框架。博客源码下载。PHP博客源码下载。对SEO超级友好。', '博客源码,博客源码下载,PHP博客源码下载', 'PHP|博客|框架', 1016, '版本1.2.0改动日志：\r\n    1、前端框架BootStrap2.0升级为3.0.3。\r\n    2、布局由全屏显示变更为居中显示。\r\n    3、将评论用户提交的URL不转换为链接。\r\n    4、将错误页面统一为BootStrap布局\r\n    5、删除多个CSS和JS，提升加载速度。\r\n    6、界面美化\r\n    7、添加TAG随即显示\r\n\r\n版本1.2.0：发布日期：2014-05-27 下载地址：https://github.com/lixuancn/LX_Blog/tree/master\r\n\r\n版本1.0.0：发布日期：2014-03-17 下载地址：http://www.lanecn.com/themes/download/blog_1.0.0.rar\r\n\r\n环境：PHP+Mysql\r\n\r\n前端：bootstrap\r\n\r\n说明：解压后是源码文件夹和数据库的MySQL文件。\r\n\r\n数据库配置信息请在config/develop/cloud.conf.php和config/online/cloud.conf.php修改。\r\n\r\nURL配置请在config/develop/sys.conf.php和config/online/sys.conf.php\r\n\r\n使用请保留鄙人的友情链接。谢谢～\r\n\r\n欢迎指正BUG。\r\n\r\n因时间关系，做的比较粗糙。细节尚未完善。\r\n\r\n可直接跟贴回复。每天都会看的。\r\n\r\n问题请直接在下方留言，邮件和论坛看的不及时。留言请注明邮件。谢谢～', 1395038461, 50, 12, 1),
(12, 4, '李轩Lane', 'MySql计数器，如网站点击数，如何实现高性能高并发的计数器功能', 'Mysql计数器功能，单一的字段在高并发下的工作并不理想，本文分享鄙人的浅见。实现高性能Mysql。在高并发下良好的工作。', 'Mysql计数器_高性能Mysql计数器_Mysql实现计数器', 'MySql计数器，如网站点击数，浏览量等，如何用Mysql实现高性能计数器，在高并发下良好的工作。', 'Mysql计数器,高性能Mysql计数器,Mysql实现计数器', 'Mysql|计数器|高性能', 1296, '现在有很多的项目，对计数器的实现甚是随意，比如在实现网站文章点击数的时候，是这么设计数据表的，如：”article_id, menu_id, article_name, article_content, article_author, article_view......在article_view中记录该文章的浏览量。诈一看似乎没有问题。对于小站，比如本博客，就是这么做的，因为小菜的博客难道会涉及并发问题吗？答案显而易见，一天没多少IP，而且以后不会很大。\r\n      言归正传，对文章资讯类为主的项目，在浏览一个页面的时候不但要进行大量的查（查询上文的记录，已经所属分类的名字、热门文章资讯评论、TAG等），还要进行写操作（更新浏览数点击数）。把文章的详细内容和计数器放在一张表尽管对开发很方便，但是会造成数据库的压力过大（不然为什么大项目都要分库分表呢）。\r\n      那么，分两张表存放就好了么？一张表存文章详细信息，另一张表单独存计数器。\r\n[code]\r\nCREATE TABLE `article_view`(\r\n    `article_id` int(11) NOT NULL,\r\n    `view` int(11) NOT NULL,\r\n    PRIMARY KEY (`article_id`)\r\n)ENGINE=InnoDB;\r\n[/code]\r\n      这种方式，虽然分担了文章表的压力，但是每当有一个进程请求更新的时候，都会产生全局的互斥锁，只能串行，不能并行。在高并发下会有较长的等待时间。\r\n      另一种比较好的办法是对每一个文章的计数器不是一行，而是多行，比如吧，一百行。每次随机更新其中一行，该文章的浏览数就是所有行的和。\r\n[code]\r\nCREATE TABLE `article_view`(\r\n    `article_id` int(11) NOT NULL,\r\n    `pond` tinyint(4) NOT NULL COMMENT ''池子，就是用来随机用的'',\r\n    `view` int(11) NOT NULL,\r\n    PRIMARY KEY (`article_id`, `pond`)\r\n)ENGINE=InnoDB;\r\n[/code]\r\n    小访问量的随机池子100个肯定多了，三五个足矣。每次访问的时候，随机一个数字（1-100）作为pond，如何该pond存在则更新view+1，否则插入，view=1。借助DUPLICATE KEY，不然在程序里是实现得先SELECT，判断一下再INSERT或者UPDATE。\r\n[code]\r\nINSERT INTO `article_view` (`article_id`, `pond`, `view`) VALUES (`123`, RAND()*100, 1) ON DUPLICATE KEY UPDATE `view`=`view`+1\r\n[/code]\r\n    获取指定文章的总访问量的时候：\r\n[code]\r\nSELECT SUM(`view`) FROM `article_view` WHERE `article_id`=''123''\r\n[/code]\r\n\r\nPs：凡事都是双刃剑。为了更快的读我们通常要牺牲一些东西。在读比较多的表要加快读的速度，在写较多的表要加快写的速度。各自权衡。在加快读的速度的时候，我们牺牲的并不仅仅是写的性能，还有开发成本，开发变的更复杂，维护成本等。所以并不是读的速度越快越好，需要找一个平衡点。\r\n\r\n注：这里仅仅是Mysql方面，有人会说高并发下你这是直接读写Mysql啦，项目的瓶颈本来就在数据库啦。。。其实。。。这里只是说Mysql的表怎么去设计而已。你完全可以在这个地方用队列去写表，你也可以把计数器在内存中保存，一直来累加，1个小时持久化一次。你也可以去用号称每秒读写十万次的Redis。', 1396107042, 42, 22, 0),
(14, 6, 'default7', '【转】恶性循环：舍不得投资，得不到回报', '文章转载自CSDN。原标题是【聊一聊】程序员的恶性循环 ！ 正好解释我现在的一些困惑。舍不得投资，就没有回报！等着得到回报后在投资，是愚蠢的！', '恶性循环_舍不得投资_得不到回报', '恶性循环,舍不得投资,得不到回报', '恶性循环,舍不得投资,得不到回报', '投资|回报', 77, '原文地址：http://bbs.csdn.net/topics/390729660\r\n\r\n穷人的恶性循环：\r\n穷 -&gt; 需要努力工作 -&gt; 没有时间去交际 -&gt; 人脉越来越狭窄 -&gt; 工作越来越难做 -&gt; 越需要努力去工作 -&gt; 越没有时间去发展人脉 -&gt; 越穷\r\n\r\n富人的良性循环：\r\n有钱 -&gt; 工作很轻松 -&gt; 很多时间都在交际上 -&gt; 人脉越来越广 -&gt; 工作越来越不用努力 -&gt; 越有更多的时间精力去发展人脉 -&gt; 越富有 \r\n\r\n程序员的恶性循环：\r\n加班 -&gt; 没空学习 -&gt; 老是写同等水平代码 -&gt; 无法提升代码质量 -&gt; 老是出BUG -&gt; 老是需要修改 -&gt; 加班 -&gt; ....\r\n\r\n\r\n\r\n想到个事情，IP5都出来的时候，我还是在用那种只能打电话接电话的直板手机，每次公司聚会的时候，老总给每个人发邮件，大家都拿出触屏的来收邮件，唯独自己一个人还是那种最老的手机 —— 三星E110C，当时自己真恨不得找个地洞钻下去，完全来错了地方一样。上司都说你每个月工资也五六K了，怎么不换个好一点的手机？穷惯了，舍不得，所受的教育一定要节俭，思想斗争，还是坚持节俭。舍不得花三四K买个好的手机。。。从小穷惯了节俭惯了，思想迂腐，只知道省钱不知道投资。\r\n\r\n\r\n还想到一个事情，我在广州天河太古汇那上班，中午吃饭，每次都不敢进那种装修好一点的餐馆吃饭。总觉得那种地方贵吧，具体有多贵自己也说不出来也不知道，反正就是一想到就觉得贵，舍不得心疼钱。然后我每次中午要跑很远去离工作地点很远的石牌城中村吃午餐，十多二十几块钱的一份盒饭，又不卫生人有超级多，但是自己一直忍着，没办法没钱，穷命穷受罪。有一次忙一个东西实在是太远，一狠心就在上班的楼下那些餐馆吃饭吧，结果一看菜单，才发现哇靠原来这么便宜，10元一份的比比皆是，而且还有座位，环境比起城中村的那些没座位还脏兮兮的好不知道多少倍。突然之间我似乎明白出一些道理。\r\n\r\n\r\n第三件事，我以前总是没有鞋子穿，不信可以看我以前在论坛水区发的贴，提问什么鞋子耐穿。那时候我每次都是找那种15元 25元一双的“亏本甩卖”的鞋店去买鞋，里面都是15 25一双，但是我总会挑选50、99一双的，为的是希望可以穿得久一点，不过很遗憾，每次都是最多2个月就破了报废了。然后每天都是没鞋子穿，每天都是穿着破鞋去上班，而屋里总是一大堆鞋子，但是都破了，每隔一两个月就要去这样的店铺买鞋子。后来偶然一次我算了一下，每月几乎要买一双鞋子，花费50到99，3个月就是150，还不如买一双好一点的名牌鞋子试试。但由于一直穿的鞋子不管是25 还是 50 还是99都是不到2个月就坏了，所以更是不敢去买几百一双的鞋子。恶性循环！最后一次铤而走险，花了几百块去专卖店买了一双某牌子的鞋子（这里还是隐藏牌号，免得广告）。发现居然穿了3个月都没坏掉现在还一直穿着很好。从此之后我再也不进那种25元一双的鞋店买鞋子\r\n\r\n\r\n第四件事，我用的第一部智能手机是HTC的,G13。当时在车上、外面看到每个人用的都是HTC，认为HTC应该是非常不错的吧，ZOL手机上都拍第二了，很牛逼吧！于是花了将近2000块在国美买了一国行HTC。不过用了几个月就越来越卡，越来越慢，512M内存。一年保修期之后 刷机了，删除自带的软件了还是就只能打电话接电话了，根本算不上智能机了。之后对只能手机产生了严重的怀疑，科技这么发达，怎么一个排名第二的智能手机这么差，不说运行游戏就连QQ都运行不了了！最后想过换三星的手机，因为都是安卓的，担心又会像HTC这样，完全就只能打电话发短信。咬牙买苹果。其实我很高心自己当时能做这样的决定，用了才发现对比之下HTC根本就不能算智能手机！苹果512M内存都可以安装无数个软件应用，而 HTC G13安装了QQ QQ空间 QQ同步助手 UC浏览器 搜狗输入法就什么都装不了，且一运行就黑屏\r\n\r\n\r\n第五件事，我在广州一家网络公司做网站程序员，月薪4K5，是我在武汉2K工资的2倍还多，心里非常哈皮，所以工作非常努力卖命。公司就我一个PHP程序员，一开始不怎么加班，但到最后我却弄得每天都加班，，，，撑了2年我最后还是累的主动辞职了，，，出来之后才发现这公司给的工资比行情低至少2K，，，，但我2年间根本从没去打探过行情，也没时间精力去打探，，，\r\n\r\n\r\n\r\n\r\n几个故事之间似乎蕴涵着一定的道理', 1397179442, 9, 6, 0),
(15, 8, '李轩Lane', '面向对象的洗礼：设计模式（一）之简单工厂模式', '设计模式，是面向对象的洗礼，面向对象的思维体操，常见的共28种设计模式，本篇谈谈设计模式中最常见的一种，那就是简单工厂模式。抽象，封装，对不同的需求进行分发，一个需求的改动不需要改变其他，低耦合，高重用。', '简单工厂模式_设计模式_设计模式之简单工厂模式', '面向对象的思维体操，设计模式中最常见的一种，简单工厂模式。以PHP的视角，来演练设计模式之简单工厂模式', '简单工厂模式,设计模式,设计模式之简单工厂模式', 'PHP|设计模式|简单工厂模式', 62, '昨晚开始看设计模式，我决定没看一种，就把它记录下来。一是晚上看，早上到公司，边写边回味。二是决定每看一章就写一篇博客，可以监督自己不会看着看着半途而废。\r\n      这应该就是一个系列博客了，书目录总共28种设计模式。这本书是我去赶集面试时推荐给我的，推荐了2本，一本大话设计模式，一本大话数据结构。想来想去，明白了一点，语言只是工具，真正的核心在于算法，设计模式，数据结构。本系列将已PHP为代码实现\r\n       设计模式是对OOP的思维体操，本篇是设计模式之简单工厂模式。\r\n       场景：实现PHP连接Mysql。\r\n[code]\r\n&lt;?php\r\n$conn = mysql_connect(''localhost'', ''root'', '''');\r\nmysql_select_db(''blog'', $conn);\r\n?&gt;\r\n[/code]\r\n       就这个？搞笑呢？项目里难道也用面向过程的？\r\n[code]\r\n&lt;?php\r\nclass MysqlDb{\r\n    private $conn = '''';\r\n    public function connect($host, $username, $password){\r\n        if(empty($conn)){\r\n            $this-&gt;conn = mysql_connect($host, $username, $password);\r\n        }\r\n    }\r\n\r\n    public function selectDb($dbName){\r\n        mysql_select_db($dbName, $this-&gt;conn);\r\n    }\r\n}\r\n?&gt;\r\n[/code]\r\n       现在，请给我加一个查询方法\r\n[code]\r\n&lt;?php\r\nclass MysqlDb{\r\n    private $conn = '''';\r\n    public function connect($host, $username, $password){\r\n        if(empty($conn)){\r\n            $this-&gt;conn = mysql_connect($host, $username, $password);\r\n        }\r\n    }\r\n\r\n    public function selectDb($dbName){\r\n        mysql_select_db($dbName, $this-&gt;conn);\r\n    }\r\n\r\n    public function query($sql){\r\n        return mysql_query($sql);\r\n    }\r\n \r\n    public function selectOne($id){\r\n        $sql = &quot;SELECT * FROM `tableName` WHERE `id` = ''&quot;.$id.&quot;'' LIMIT 0, 1&quot;;\r\n        return $this-&gt;query($sql);\r\n    }\r\n\r\n    public function selectList($id = ''''){\r\n        if(!empty($id)){\r\n             $where = &quot;WHERE `id` = ''&quot;.$id.&quot;''&quot;;\r\n        }\r\n        $sql = &quot;SELECT * FROM `tableName`&quot;.$where;\r\n        return $this-&gt;query($sql);\r\n    }\r\n}\r\n?&gt;\r\n[/code]\r\n       好，现在项目发展了，单单Mysql不能满足需求了，请给我添加一个Redis。\r\n[code]\r\n&lt;?php\r\nclass RedisDb{\r\n    private $conn = '''';\r\n    public function connect($host, $username, $password){\r\n        if(empty($conn)){\r\n            $this-&gt;conn = new Redis();\r\n            $this-&gt;conn-&gt;connect($host, $port);\r\n            $this-&gt;conn-&gt;auth($password);\r\n            $this-&gt;conn-&gt;select($dbName);\r\n        }\r\n    }\r\n \r\n    public function getValue($key){\r\n        return $this-&gt;conn-&gt;get($key);\r\n    }\r\n\r\n    public function setValue($key, $value){\r\n        return $this-&gt;conn-&gt;set($key, $value);\r\n    }\r\n}\r\n?&gt;\r\n[/code]\r\n       好了，难道每次都要在代码里调用这2个类？当然不！\r\n[code]\r\n&lt;?php\r\n/**\r\n * 数据库工厂类 - 这就是简单工厂模式的分发。调用上面的几个类\r\n */\r\nclass DbFactory{\r\n    private static $dbObj = '''';\r\n    public static function init($dbType){\r\n        if(empty(self::$dbObj)){\r\n            self::$dbObj = self::dbSwitch($dbType);\r\n        }\r\n        return $dbObj;\r\n    }\r\n  \r\n    private static function dbSwitch($dbType){\r\n        $dbType = strtolower($dbType);\r\n        $obj = '''';\r\n        switch($dbType){\r\n            case ''mysql'':\r\n                $obj = new MysqlDb();\r\n                break;\r\n            case ''redis'':\r\n                $obj = new RedisDb();\r\n                break;\r\n            case ''mysqli'':\r\n                $obj = new MysqliDb();\r\n                break;\r\n            case ''pdo'':\r\n                $obj = new PdoDb();\r\n                break;\r\n             default :\r\n                exit(''非法操作'');\r\n        }\r\n        return $obj;\r\n    }\r\n}\r\n?&gt;\r\n[/code]', 1397522886, 5, 6, 0),
(16, 8, '李轩Lane', '面向对象的洗礼：设计模式（二）之策略模式', '策略模式，策略就是算法和变化，策略模式就是对算法和变化的封装。是条件选择从客户端到服务端的转移。客户端与算法类的彻底隔离。以PHP代码实现', '策略模式_设计模式_设计模式之策略模式（算法的封装））', 'PHP策略模式，策略就是算法和变化，策略模式就是对算法和变化的封装。是条件选择从客户端到服务端的转移。客户端与算法类的彻底隔离', 'PHP策略模式,设计模式,设计模式之策略模式（算法的封装））', 'PHP|设计模式|策略模式', 51, '策略模式，策略就是算法和变化，策略模式就是对算法和变化的封装。是条件选择从客户端到服务端的转移。客户端与算法类的彻底隔离。\r\n[code]\r\n&lt;?php\r\nabstract class Strategy{\r\n    public $paramA = '''';\r\n    public $paramB = '''';\r\n    public function getResult(){\r\n\r\n    }\r\n}\r\nclass AlgorithmA extends Strategy{\r\n    public function algorithmA(){\r\n        //算法A的实现\r\n    }\r\n}\r\nclass AlgorithmB extends Strategy{\r\n    public function algorithmB(){\r\n        //算法B的实现\r\n    }\r\n}\r\nclass AlgorithmC extends Strategy{\r\n    public function algorithmC(){\r\n        //算法C的实现\r\n    }\r\n}\r\n?&gt;\r\n[/code]\r\n场景： 沃尔玛要做一个收银软件。有打8折，打5折等，有每满100减20等。\r\n[code]\r\n&lt;?php\r\n//抽象类\r\nabstract class Pay{\r\n    public $cash = '''';\r\n    public $total = '''';\r\n    public function getResult(){\r\n        return $this-&gt;total;\r\n    }\r\n}\r\n//打折\r\nclass Discount extends Pay{\r\n    public function algorithm($cash, $discount=0.8){\r\n        $this-&gt;total = $cash * $discount;\r\n        return $this-&gt;getResult();\r\n    }\r\n}\r\n//满多少减多少\r\nclass Reduce extends Pay{\r\n    public function algorithm($cash, $satisfied=100, $returnCash=20){\r\n        $this-&gt;total = $cash - floor($cash / $satisfied) * $returnCash;\r\n        return $this-&gt;getResult();\r\n    }\r\n}\r\nclass Context{\r\n    private $obj;\r\n    public function __construct($type){\r\n        switch($type){\r\n            case 1:\r\n                $this-&gt;obj = new Discount();\r\n                break;\r\n            case 2:\r\n                $this-&gt;obj = new Reduce();\r\n                break;\r\n        }\r\n    }\r\n    public function algorithm(){\r\n        $this-&gt;obj-&gt;algorithm();\r\n    }\r\n}\r\n//客户端\r\n$obj = new Context($_GET[''type'']);\r\necho $obj-&gt;algorithm();\r\n?&gt;\r\n[/code]\r\n优点：客户端不需要做条件判断，而且仅仅需要认识一个类即可。乍一看和简单工厂很相似呢。', 1397610188, 10, 10, 0),
(17, 8, '李轩Lane', '面向对象的洗礼：设计模式（三）之单一原则，避免万能类', '面向对象的软件开发中，有一个基本原则，那就是单一原则，是设计模式的重点。单一原则，功能单一的类，避免万能类。如果一个类的空能多于一点，就应该拆分成2个类。是面向对象的设计模式中最重要的一个原则。', '单一原则_设计模式_设计模式之单一原则_避免万能类', '面向对象的软件开发中，有一个基本原则，那就是单一原则，是设计模式的重点。单一原则，功能单一的类，避免万能类', '单一原则,设计模式,设计模式之单一原则,避免万能类', 'PHP|设计模式|单一原则', 39, '面向对象的软件开发中，有一个基本原则，那就是单一原则，是设计模式的重点。单一原则，功能单一的类，避免万能类。如果一个类的空能多于一点，就应该拆分成2个类。是面向对象的设计模式中最重要的一个原则。\r\n      举个例子，在智能手机刚刚出现的时候，诺基亚占据世界大半壁江山。智能手机可以打电话，发短信，浏览网页，玩游戏，拍照，录像等等，但是，拿拍照来说，拍照比不过傻瓜相机（如今也比不过单反）。尽管将大量的功能融合为一台设备，携带和充电更方便，但是效果并不如单一功能的强大。这就引入了“单一原则”。\r\n      在软件开发过程中，单一原则是设计模式中非常重要的思想。如果，你能够在一个类中找到多于一个的功能，那么，这个类就该进行抽象和拆分了。在OOP中有一个大忌讳，就是万能类。一个成千上万行的类，臃肿而庞大，为什么不柴分成多个类呢？每个类负责一个功能，各思其职。', 1397697496, 5, 5, 0),
(18, 8, '李轩Lane', '面向对象的洗礼：设计模式（四）之开放-封闭原则', '开放-封闭原则，是面向对象的核心思想，使用开放-封闭原则的设计模式，可以获得那些声称使用面向对象可以获得的巨大好处，即可扩展性，易维护性，高复用性，超灵活性。', '开放-封闭原则_设计模式_设计模式之开放-封闭原则', '开放-封闭原则，是面向对象的核心思想，使用开放-封闭原则的设计模式，可以获得那些声称使用面向对象可以获得的巨大好处。', '开放-封闭原则,设计模式,设计模式之开放-封闭原则', 'PHP|设计模式|开放-封闭原则', 41, '开放-封闭原则，是面向对象的核心思想，使用开放-封闭原则的设计模式，可以获得那些声称使用面向对象可以获得的巨大好处，即可扩展性，易维护性，高复用性，超灵活性。\r\n      开放原则：对扩展时开放的！\r\n      封闭原则：对修改时关闭的！\r\n      就是说，一个良好的类，欢迎其他的类去继承它，使用它。但是，不欢迎对它进行修改。如果要修改，以便实现新功能，那么，不如去新开发一个类。当然，绝对的不修改是不可能的。这就要求在开发中多思考，多考虑将来有可能面对的修改，降低对某个特定功能的耦合度。\r\n      请注意，开放-封闭原则在OOP中的地位，是核心思想！\r\n      扩展性：容易新增多个软件包；\r\n      维护性：维护时只需要修改一个类中的一个函数即可，完全不会涉及到其他的代码；\r\n      复用性：随时随地，拿来就用；\r\n      灵活性：因为可以扩展，容易维护，可以复用，所以灵活。\r\n      举例：一台电脑，内存条坏了只需要拔下内存条即可，显卡需要升级只需要拔下旧显卡，插上新显卡。CPU风扇坏了只需要更换风扇而不需要更换CPU。无论是Inter还是AMD，每一小块芯片都有许多的复杂的指令集，我们不需要知道。内存条厂商也不需要知道CPU和主板的指令集，将内存条根据针脚插入主板中，就可以工作，因为它依靠针脚（接口）来传输数据。各个硬件之间相互独立。对某个硬件而言，对内我的指令集和工作方式是封闭的，你不可以修改也不需要知道，对外，我有接口，支持扩展，大家可以把我插了就用。这就是开放-封闭原则的体现。是高聚能低耦合的典型例子。', 1397698194, 4, 5, 0);
INSERT INTO `info_article` (`id`, `mid`, `author`, `title`, `description`, `seo_title`, `seo_description`, `seo_keywords`, `tag`, `clicks`, `content`, `ctime`, `good_num`, `bad_num`, `recommend_type`) VALUES
(19, 8, '李轩Lane', '面向对象的洗礼：设计模式（五）之依赖倒转原则', '依赖倒转原则，是面向对象的标识，以里氏代换原则为基础，使的开放-封闭原则的实现成为了可能。针对接口的而不是针对实现编程。', '依赖倒转原则_设计模式_设计模式之依赖倒转', '依赖倒转原则，是面向对象的标识，以里氏代换原则为基础，使的开放-封闭原则的实现成为了可能。', '依赖倒转原则，是面向对象的标识，以里氏代换原则为基础，使的开放-封闭原则的实现成为了可能。针对接口的而不是针对实现编程。', 'PHP|设计模式|依赖倒转原则', 85, '依赖倒转原则，是面向对象的标识，以里氏代换原则为基础，使的开放-封闭原则的实现成为了可能。针对接口的而不是针对实现编程。\r\n      场景：高内聚低耦合的计算机主机，上篇中提到过的例子http://www.lanecn.com/article/main/aid-18。内存坏了可以直接拔掉换一个新的，不会说华硕的主板就不能插你刚从戴尔的主板上拔下的内存。所以，内存条的设计是针对接口的，是一个统一的标准接口，不是一个主板厂商提供一个接口方式。再所以一下，内存条的设计不是为了实现而去设计的，如果是为了实现，那么我现在要实现它插在戴尔主板上的内存条，它在华硕主板就不能用了。由此，引出一个原则“依赖倒转原则”。\r\n      依赖倒转原则：针对接口编程，而不是针对实现编程。高层模块不能依赖于底层模块，而是两者都共同依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。\r\n      新手总是面向过程的开发，把常用的函数都写成底层的函数。比如数据库操作函数。客户端直接调用数据库操作函数。那么假如有一天客户要求更改数据库呢？就要修改底层的数据库操作函数，但是，&lt;a href=&quot;http://www.lanecn.com/article/main/aid-18&quot;&gt;面向对象的洗礼：设计模式（四）之开放-封闭原则&lt;/a&gt;，对修改是封闭的，不应该用修改的方式，而是用扩展的方式，把相同的操作函数都抽象出来。所以是针对接口，而不是针对实现。另一个原则为针对接口的编程在修改时不需要修改代码，而是扩展的开放-封闭原则提供了实现的原理保障。\r\n      里氏代换原则：子类继承父类，则子类可以完全代替父类的所有功能，而不会被使用者察觉。\r\n      对于外部只能调用父类的所有public方法，子类则都可以继承过来。\r\n      里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：\r\n            2、子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。\r\n            3、子类中可以增加自己特有的方法。\r\n            4、当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。\r\n            5、当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。\r\n\r\n      反面案例：收音机！芯片，喇叭什么的一大堆焊接在一起，超高的耦合度！', 1397782506, 17, 10, 0),
(20, 8, '李轩Lane', '面向对象的洗礼：设计模式（六）之装饰模式', '装饰模式，动态的给一个对象添加一些额外的职责，就增加的功能来说，装饰模式比生成子类更为灵活。设计模式之装饰模式。每个装饰对象的实现和如何使用这个对象分离了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链中。', '装饰模式_设计模式_设计模式之装饰模式', '装饰模式，动态的给一个对象添加一些额外的职责，就增加的功能来说，装饰模式比生成子类更为灵活。设计模式之装饰模式。', '装饰模式,设计模式,设计模式之装饰模式', 'PHP|设计模式|装饰模式', 45, '装饰模式，动态的给一个对象添加一些额外的职责，就增加的功能来说，装饰模式比生成子类更为灵活。设计模式之装饰模式。每个装饰对象的实现和如何使用这个对象分离了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链中。\r\n[code]\r\n&lt;?php\r\nabstract class Component{\r\n    public function operation(){\r\n\r\n    }\r\n}\r\nclass ConcreteComponent extends Component{\r\n    public function operation(){\r\n        echo ''具体对象操作'';\r\n    }\r\n}\r\n\r\nabstract class Decorator extends Component{\r\n    protected $component;\r\n    public function setComponet($objComponent){\r\n        $this-&gt;component = $objComponent;\r\n    }\r\n    public function sonOperation(){\r\n        if(empty($this-&gt;component)){\r\n            $this-&gt;operation();\r\n        }\r\n    }\r\n}\r\nclass ConcreteDecoratorA extends Decorator{\r\n    private $addState;\r\n    public function concteteOperation(){\r\n        $this-&gt;operation();\r\n        $this-&gt;addState = ''New State'';\r\n        echo ''具体装饰对象A的操作'';\r\n    }\r\n}\r\nclass ConcreteDecoratorB extends Decorator{\r\n    public function concreteOperation(){\r\n        $this-&gt;operation();\r\n        $this-&gt;addBehavior();\r\n        echo ''具体操作对象B的操作'';\r\n    }\r\n    public function addBehavior(){\r\n\r\n    }\r\n}\r\n$cObj = new ConcreteComponent();\r\n$d1Obj = new ConcreteDecoratorA();\r\n$d2Obj = new ConcreteDecoratorB();\r\n//装饰的方法是，先实例化对象c，用d1包装c，用d2包装d1，最终通过d2来执行operation\r\n$d1Obj-&gt;setComponet($cObj);\r\n$d2Obj-&gt;setComponet($d1Obj);\r\n$d2Obj-&gt;sonOperation();\r\n?&gt;\r\n[/code]\r\n\r\n       装饰模式是为已有的功能动态的添加更多功能的一种方式。当系统需要新功能的时候，是向旧类中添加新代码。这些新代码通常装饰了原有的类的核心职责或主要行为。新加入的代码仅仅是在满足一定特定条件下才会被需要。而装饰模式提供了一个解决方案。把每个要装饰的功能放在单独类中。需要执行特殊行为时，客户端代码可以有选择的有顺序的去使用装饰功能包装对象。\r\n      装饰模式就是把类中的装饰功能删掉，简化原类，把核心职责和装饰区分开。\r\n      场景：数据加密和数据过滤是我们在写入数据库前要做的工作，那么先加密再过滤和先过滤再加密，结果肯定是不一样的。所以，保证加密和过滤这2个类彼此独立，如果使用，在客户端进行不同的组合。', 1397892233, 10, 9, 0),
(21, 8, '李轩Lane', '面向对象的洗礼：设计模式（七）之代理模式', '代理模式，是为其他对象提供一种代理以控制对这个对象的访问，代理模式是设计模式的一种。应用较为广泛，是一个对象需要访问另一个对象，出于某种原因或目的，在两个对象之间添加了一个中间对象。A对象访问B对象的方法，B对象的该方法实际是调用的C对象的方法，间接的完成了A对象对C对象的访问。这种模式叫做代理模式。', '代理模式_设计模式_设计模式之代理模式', '代理模式，是为其他对象提供一种代理以控制对这个对象的访问，代理模式是设计模式的一种。是很常见的一种代码书写方法。', '代理模式,设计模式,设计模式之代理模式', 'PHP|设计模式|代理模式', 50, '代理模式，是为其他对象提供一种代理以控制对这个对象的访问，代理模式是设计模式的一种。应用较为广泛，是一个对象需要访问另一个对象，出于某种原因或目的，在两个对象之间添加了一个中间对象。A对象访问B对象的方法，B对象的该方法实际是调用的C对象的方法，间接的完成了A对象对C对象的访问。这种模式叫做代理模式。\r\n      以PHP为代码环境，实现设计模式中的代理模式。\r\n[code]\r\n&lt;?php\r\nabstract class Subject(){\r\nabstract class Subject(){\r\n    public function actionA();\r\n	public function actionB(){;\r\n    public function actionC();\r\n}\r\nclass Substance implements Subject(){\r\n    public function actionA(){\r\n        echo ''方法A的实现'';	\r\n	}\r\n	public function actionB(){\r\n        echo ''方法B的实现'';\r\n	}\r\n    public function actionC(){\r\n	    echo ''方法C的实现'';\r\n    } \r\n}\r\nclass Proxy implements Subject(){\r\n    $protected $obj;\r\n	public function __construct(){\r\n        $obj = new Substance();\r\n    }\r\n    public function actionA(){\r\n        $this-&gt;obj-&gt;actionA;\r\n    }\r\n    public function actionB(){\r\n        $this-&gt;obj-&gt;actionB;\r\n    }\r\n    public function actionC(){\r\n	    $this-&gt;obj-&gt;actionC;\r\n    } \r\n}\r\n//客户端/接口\r\n$obj = new Proxy();\r\n$obj-&gt;actionA();\r\n$obj-&gt;actionB();\r\n$obj-&gt;actionC();	\r\n}\r\n?&gt;\r\n[/code]\r\n    代理模式的使用场景：（整理自大话设计模式一书）\r\n      第一、远程代理，为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。\r\n      第二、虚拟代理，是根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的对象。\r\n      第三、安全代理，用来控制真实对象的访问权限。\r\n      第四、智能指引，是指当调用真实对象时，代理处理另外一些事情。（我的理解是，比如底层有一个封装好的Mysql类，在上层应用层读取数据库时，先经过一个代理类，可以检查数据完整性，参数合法性，计数器等等，然后由代理类调用真实的Mysql类）', 1397995422, 12, 10, 0),
(22, 8, '李轩Lane', '面向对象的洗礼：设计模式（八）之工厂方法', '工厂方法来源于简单工厂模式，是简单工厂模式的一个衍生品。核心的工厂类不再进行类的实例化，核心工厂类不再负责产品的创建，核心的工厂类只负责子类的接口，使核心工厂类抽象化，成为一个抽象工厂。', '工厂方法_设计模式_设计模式之工厂方法', '工厂方法来源于简单工厂模式，是简单工厂模式的一个衍生品。核心的工厂类不再进行类的实例化，核心工厂类不再负责产品的创建，核心的工厂类只负责子类的接口，使核心工厂类抽象化，成为一个抽象工厂。', '工厂方法,设计模式,设计模式之工厂方法', 'PHP|设计模式|工厂方法', 90, '工厂方法：定义一个工厂接口，用来创建产品对象，将实际创建工作推迟到子类当中。\r\n      工厂方法来源于简单工厂模式，是简单工厂模式的一个衍生品。核心的工厂类不再进行类的实例化，核心工厂类不再负责产品的创建，核心的工厂类只负责子类的接口，使核心工厂类抽象化，成为一个抽象工厂。\r\n      工厂方法的优点：在简单工厂模式的基础上再次对核心工厂类进行抽象，在需要添加新的产品时，更好的依赖于开放-封闭原则，不需要修改具体的工厂角色即可扩展。\r\n      场景：简单计算器。以PHP为代码实现环境。\r\n简单工厂模式：\r\n[code]\r\n&lt;?php\r\nclass Calculator{\r\n    public $numberA;\r\n    public $numberB;\r\n    public $result;\r\n    public function returnResult(){\r\n\r\n    }\r\n}\r\nclass Add extends Calculator{\r\n    public function __construct($a, $b){\r\n        $this-&gt;numberA = $a;\r\n        $this-&gt;numberB = $b;\r\n    }\r\n    public function returnResult(){\r\n        $this-&gt;result = $this-&gt;numberA + $this-&gt;numberB;\r\n        return $this-&gt;returnResult();\r\n    }\r\n}\r\nclass Sub extends Calculator{\r\n    public function __construct($a, $b){\r\n        $this-&gt;numberA = $a;\r\n        $this-&gt;numberB = $b;\r\n    }\r\n    public function returnResult(){\r\n        $this-&gt;result = $this-&gt;numberA - $this-&gt;numberB;\r\n        return $this-&gt;returnResult();\r\n    }\r\n}\r\nclass Factory{\r\n    public function calculatorFactory($operator, $numberA, $numberB){\r\n        $obj = '''';\r\n        switch($operator){\r\n            case ''+'':\r\n                $obj = new Add($numberA, $numberB);\r\n                break;\r\n            case ''-'':\r\n                $obj = new Sub($numberA, $numberB);\r\n                break;\r\n        }\r\n        $result = $obj-&gt;returnResult();\r\n        return $result;\r\n    }\r\n}\r\n//客户端/接口\r\n$operation = isset($_GET[''operation'']) ? $_GET[''operation''] : ''+'';\r\n$numberA = $_GET[''numberA''];\r\n$numberB = $_GET[''numberB''];\r\n$obj = new Factory();\r\necho $obj-&gt;calculatorFactory($operation, $numberA, $numberB);\r\n?&gt;\r\n[/code]\r\n工厂方法：\r\n[code]\r\n&lt;?php\r\nclass Calculator{\r\n    public $numberA;\r\n    public $numberB;\r\n    public $result;\r\n    public function returnResult(){}\r\n}\r\nclass Add extends Calculator{\r\n    public function __construct($a, $b){\r\n        $this-&gt;numberA = $a;\r\n        $this-&gt;numberB = $b;\r\n    }\r\n    public function returnResult(){\r\n        $this-&gt;result = $this-&gt;numberA + $this-&gt;numberB;\r\n        return $this-&gt;returnResult();\r\n    }\r\n}\r\nclass Sub extends Calculator{\r\n    public function __construct($a, $b){\r\n        $this-&gt;numberA = $a;\r\n        $this-&gt;numberB = $b;\r\n    }\r\n    public function returnResult(){\r\n        $this-&gt;result = $this-&gt;numberA - $this-&gt;numberB;\r\n        return $this-&gt;returnResult();\r\n    }\r\n}\r\nclass Factory extends Calculator{\r\n    public static function create($class, $numberA, $numberb){\r\n        return new $class($numberA, $numberb);\r\n    }\r\n}\r\n//客户端/接口\r\n$operator = isset($_GET[''operation'']) ? $_GET[''operation''] : ''+'';\r\n$numberA = $_GET[''numberA''];\r\n$numberB = $_GET[''numberB''];\r\nswitch($operator){\r\n    case ''+'':\r\n        $class = ''objAdd'';\r\n        break;\r\n    case ''-'':\r\n        $class = ''objSub'';\r\n        break;\r\n}\r\n$obj = Factory::create($class, $numberA, $numberb);\r\necho $obj-&gt;returnResult();\r\n?&gt;\r\n[/code]\r\n\r\n简单工厂模式VS工厂方法模式：\r\n简单工厂的选择在工厂类，', 1398039722, 10, 11, 0),
(23, 8, '李轩Lane', '面向对象的洗礼：设计模式（九）之原型模式', '原型模式提取重复功能，避免了程序员喜欢复制粘贴的坏习惯。设计模式中的原型模式就是，用原型实例指定创建对象的重力，通过拷贝这些原型来创建新的对象从一个对象再创建另外一个可定制的对象，而且不需要知道创建的任何细节。', '原型模式_设计模式_设计模式之原型模式', '原型模式提取重复功能，避免了程序员喜欢复制粘贴的坏习惯。设计模式中的原型模式就是，用原型实例指定创建对象的重力，通过拷贝这些原型来创建新的对象。', '原型模式,设计模式,设计模式之原型模式', 'PHP|设计模式|原型模式', 47, '原型模式提取重复功能，避免了程序员喜欢复制粘贴的坏习惯。设计模式中的原型模式就是，用原型实例指定创建对象的重力，通过拷贝这些原型来创建新的对象从一个对象再创建另外一个可定制的对象，而且不需要知道创建的任何细节。\r\n      浅复制 VS 深复制：\r\n      浅复制是对数字，字符串等类型进行传值复制，而对对象来讲是引用复制，即只是对内存地址进行赋值而不是新建一个对象的变量。在浅复制中，对一个对象的属性改变，另一个对象的该属性也会被改变，类比于C语言的指针，PHP在调用方法时&amp;$var的传递。\r\n      以PHP为代码环境。\r\n[code]\r\n&lt;?php\r\n//家庭类\r\nclass Home{\r\n    public $money;\r\n    public function __construct($money){\r\n        $this-&gt;money = $money;\r\n	}\r\n}\r\n//家庭成员类\r\nclass member{\r\n    public $id;\r\n    public $name;\r\n    public $obj;\r\n    public function __construct($id, $name, Home $obj){\r\n        $this-&gt;setId($id);\r\n        $this-&gt;setName($name);\r\n		$this-&gt;obj = $obj;\r\n    }\r\n    public function setId($id){\r\n        $this-&gt;id = $id;\r\n    }\r\n	public function setName($name){\r\n        $this-&gt;name = $name;\r\n    }\r\n    public function display(){\r\n	    echo ''ID为'' . $this-&gt;id . ''，名称为'' . $this-&gt;name . ''，资产为'' . $this-&gt;obj-&gt;money . ''&lt;br&gt;'';\r\n    }\r\n	public function __clone(){\r\n        //深度复制（克隆），因为克隆只能克隆数字，字符串等，对对象变量是引用传值。	\r\n        $this-&gt;obj = clone $this-&gt;obj;\r\n    }\r\n}\r\n//客户端/接口\r\n$obj1 = new member(1, ''小轩'', new Home(''10000''));\r\n$obj1-&gt;display();\r\n$obj2 = clone $obj1;\r\n$obj2-&gt;setId(2);\r\n$obj2-&gt;setName(''小玮'');\r\n$obj2-&gt;obj-&gt;money = 2000;\r\n$obj2-&gt;display();\r\n//根据这句输出可以看到，对象1和对象2值是不一样的，删掉上面的注释部分再看，又是一样的了，这就是深复制和浅复制。\r\n$obj1-&gt;display();\r\n?&gt;\r\n[/code]', 1398088115, 10, 8, 0),
(24, 8, '李轩Lane', '面向对象的洗礼：设计模式（十）之模板方法模式', '模板方法模式，是最为常见，也是使用最为广泛的一种设计模式，很多程序猿都不知道，自己随便写的代码，也是一种设计模式。如果只能学习一种设计模式的话，那么就应该学习模板模式。顾名思义，模板模式，就是有一个固定的，现成的模板，往里面套东西呗。比如PPT，WORD，EXCEL等，Microsoft为我们提供了大量的模板。可以直接套用，也可以略做修改。总之，比我们自己全新做要省很多事儿。', '模板方法模式_设计模式_设计模式之模板方法模式', '模板方法模式，是最为常见，也是使用最为广泛的一种设计模式，很多程序猿都不知道，自己随便写的代码，也是一种设计模式。如果只能学习一种设计模式的话，那么就应该学习模板模式。', '模板方法模式,设计模式,设计模式之模板方法模式', 'PHP|设计模式|模板方法模式', 49, '模板方法模式，是最为常见，也是使用最为广泛的一种设计模式，很多程序猿都不知道，自己随便写的代码，也是一种设计模式。如果只能学习一种设计模式的话，那么就应该学习模板模式。\r\n       模板模式：在一个方法里定义算法的骨架，将一些步骤延迟到其子类。顾名思义，模板模式，就是有一个固定的，现成的模板，往里面套东西呗。比如PPT，WORD，EXCEL等，Microsoft为我们提供了大量的模板。可以直接套用，也可以略做修改。总之，比我们自己全新做要省很多事儿。\r\n       抽出多个类的共同特性，成为一个父类，父类根据需求封装好一个算法骨架，然后子类调用父类即可。\r\n       以PHP为代码环境，\r\n[code]\r\n&lt;?php\r\nclass TestPaper{\r\n    public $name;\r\n    public $classes;\r\n    public function __construct($name, $classes){\r\n        $this-&gt;name = $name;\r\n        $this-&gt;classes = $classes;\r\n    }\r\n    public function display(){\r\n        echo ''姓名：'' . $this-&gt;name . ''， 班级：'' . $this-&gt;classes;\r\n        $this-&gt;separate();\r\n    }\r\n    public function title1($answer){\r\n        echo ''题目一：******'';\r\n        echo ''答案：'' . $this-&gt;answer($answer);\r\n        $this-&gt;separate();\r\n    }\r\n    public function title2($answer){\r\n        echo ''题目二：******'';\r\n        echo ''答案：'' . $this-&gt;answer($answer);\r\n        $this-&gt;separate();\r\n    }\r\n    public function answer($answer){\r\n        return $answer;\r\n    }\r\n    public function separate(){\r\n        echo ''&lt;br&gt;'';\r\n    }\r\n}\r\nclass studentA extends TestPaper{\r\n    public function __construct($name, $classes){\r\n        parent::__construct($name, $classes);\r\n    }\r\n    public function answerTestPaper(){\r\n        $this-&gt;display();\r\n        $this-&gt;title1(''C'');\r\n        $this-&gt;title1(''B'');\r\n    }\r\n}\r\nclass studentB extends TestPaper{\r\n    public function __construct($name, $classes){\r\n        parent::__construct($name, $classes);\r\n    }\r\n    public function answerTestPaper(){\r\n        $this-&gt;display();\r\n        $this-&gt;title1(''A'');\r\n        $this-&gt;title1(''D'');\r\n    }\r\n}\r\n$studentA = new studentA(''小明'', ''一'');\r\n$studentA-&gt;answerTestPaper();\r\n$studentB = new studentB(''小红'', ''二'');\r\n$studentB-&gt;answerTestPaper();\r\n?&gt;\r\n[/code]', 1398126858, 10, 11, 0),
(25, 8, '李轩Lane', '面向对象的洗礼：设计模式（十一）之迪米特法则', '迪米特法则，再次强调了面向对象的特性之一：封装。不需要知道具体如何实现的细节，只需要调用某个类的方法，得到预期的结果。尽可能少的使用public，降低成员的访问权限。可以更好降低类与类之间的耦合度。程序设计时，修改一个越弱耦合的类，对系统造成的影响就会越小，耦合度越低，越利于复用。这就是迪米特法则的根本思想。', '迪米特法则_设计模式_设计模式之迪米特法则', '迪米特法则，再次强调了面向对象的特性之一：封装。设计模式的原则之一的迪米特法则，它的根本思想是程序设计时，修改一个越弱耦合的类，对系统造成的影响就会越小，耦合度越低，越利于复用。', '迪米特法则,设计模式,设计模式之迪米特法则', 'PHP|设计模式|迪米特法则', 40, '面向对象的特性之一：封装。不需要知道具体如何实现的细节，只需要调用某个类的方法，得到预期的结果。尽可能少的使用public，降低成员的访问权限。可以更好降低类与类之间的耦合度。程序设计时，修改一个越弱耦合的类，对系统造成的影响就会越小，耦合度越低，越利于复用。这就是迪米特法则的根本思想。\r\n       依赖接口而不是依赖实现，在弱耦合、低权限的基础上，完全不需要关心接口的实现细节，这也就是依赖倒转原则。面向对象的原则和面向对象的特性是不对立的。\r\n       迪米特法则：如果两个类，不需要直接进行两个类之间的通信，那么，这两个类就不应该直接发生作用和求情，如果一个类在特定条件下需要调用另一个类，那么，可以通过第三个类来实现，转发这个调用。\r\n       是不是又用点像代理模式？代理模式是针对对象的，代理类实例化真实类，调用真实类的方法。而迪米特法则是一个类调用另一个类，然后这个另一个类再调用另另一个类。', 1398174088, 9, 9, 0),
(26, 8, '李轩Lane', '面向对象的洗礼：设计模式（十二）之外观模式', '外观模式其实非常容易用到，是对迪米特法则的一种应用：降低类的耦合度，添加中间件。也是对依赖倒转原则的完美体现：针对接口的编程。作为一个中间件，降低底层接口和使用者（客户端的）耦合度。', '外观模式_设计模式_设计模式之外观模式', '外观模式其实非常容易用到，是对迪米特法则的一种应用：降低类的耦合度，添加中间件。也是对依赖倒转原则的完美体现：针对接口的编程。', '外观模式,设计模式,设计模式之外观模式', 'PHP|设计模式|外观模式', 55, '外观模式其实非常容易用到，是对迪米特法则的一种应用：降低类的耦合度，添加中间件。也是对依赖倒转原则的完美体现：针对接口的编程。\r\n       外观模式：再次针对某个接口封装一个高层类，实现一个高层接口，按某种算法或使用方式整合底层接口类，使得底层的接口更加容易使用，也降低了底层接口和客户端的耦合度。\r\n       场景：调用数据库。以PHP为代码环境，以Mysql为数据库环境。\r\n[code]\r\n&lt;?php\r\nclass MysqlDB{\r\n    private $conn;\r\n    public function __construct($host, $username, $password, $dbName){\r\n        $this-&gt;conn($host, $username, $password);\r\n        $this-&gt;selectDb($dbName);\r\n    }\r\n    private function conn($host, $username, $password){\r\n        $this-&gt;conn = mysql_connect($host, $username, $password);\r\n    }\r\n    private function selectDb($dbName){\r\n        mysql_select_db($dbName, $this-&gt;conn);\r\n    }\r\n    public function query($sql){\r\n        return mysql_query($sql);\r\n    }\r\n    public function fetchArray($queryResult){\r\n        return mysql_fetch_array($queryResult);\r\n    }\r\n	public function fetchAssoc($queryResult){\r\n        return mysql_fetch_assoc($queryResutl);\r\n    }\r\n}\r\nclass Facade{\r\n    private $mysqlObj;\r\n	public function __construct($host, $username, $password, $dbName){\r\n        $this-&gt;mysqlObj = new MysqlDB($host, $username, $password, $dbName);\r\n    }\r\n    public function get($tableName){\r\n        $sql = ''SELECT * FROM '' . $tableName;\r\n        $queryResult = $this-&gt;mysqlObj-&gt;query($sql);\r\n        $fetchArr = $this-&gt;myqlObj-&gt;fetchAssoc($queryResult);\r\n		return $fetchArr\r\n    }\r\n}\r\n//客户端/接口\r\n$obj = new Facade(''localhost'', ''root'', ''root'', ''db_name'');\r\n$list = $obj-&gt;get(''user_info'');\r\n?&gt;\r\n[/code]\r\n\r\n       常见的使用场景：\r\n       1、开发的初期阶段，有意识的建立中间件，将不同的两层分离，在层与层之间建立外观。\r\n       2、在开发阶段，某个类会根据需求的不断变更等原因使类变得更加复杂而庞大，增加一个外观类，使的使用者和这个庞大负责的类耦合降低。\r\n       3、历史遗留问题。需要用到遗留的复杂逻辑的类，直接调用是不好的，所以需要一个中间件（外观模式的外观类）来调用这个复杂类，而使用者调用外观类即可。\r\n       可以理解为，外观模式的外观类，是一个入口，使用者调用外观类，外观类调用底层的类。', 1398174892, 13, 17, 0),
(27, 8, '李轩Lane', '面向对象的洗礼：设计模式（十三）之建造者模式', '建造者模式，也叫生成器模式。是设计模式的一种。某个复杂算法类，在方法调用上是顺序稳定的，但是具体属性不同，此时可以使用建造者模式。在建造者模式这一的设计模式种，第一个类builder是各种创建方法的抽象接口。ConcreteBuilder调用Builder的接口来装配。提供对外的接口。ProductA是A产品类，调用ConcreteBuilder实现了具体的产品A的实现方法，也就是需要被构造的那个复杂的对象。Director就是我们的向导类，根据客户的需求生成产品A、产品B、产品C。', '建造者模式_设计模式_设计模式之建造者', '建造者模式，也叫生成器模式。是设计模式的一种。某个复杂算法类，在方法调用上是顺序稳定的，但是具体属性不同，此时可以使用建造者模式。', '建造者模式,设计模式,设计模式之建造者', 'PHP|设计模式|建造者模式', 47, '建造者模式，也叫生成器模式。是设计模式的一种。某个复杂算法类，在方法调用上是顺序稳定的，但是具体属性不同，此时可以使用建造者模式。\r\n       建造者模式：一个复杂的对象，我们把它的构造和它的表示分离，可以实现同样的构造，而产生多种不同的表示，这种设计模式我们把它叫做建造者模式，也被成为生成器模式。顾名思义，在一个厂房中批量生成。\r\n       在定义和开发时，必须要满足：1、我们开发的类，允许被它的对象有多种不同的表示。2、当创建复杂对象的算法，应该独立于该对象的组成部分和该对象的装配方式。\r\n       在建造者模式这一的设计模式种，第一个类builder是各种创建方法的抽象接口。ConcreteBuilder调用Builder的接口来装配。提供对外的接口。ProductA是A产品类，调用ConcreteBuilder实现了具体的产品A的实现方法，也就是需要被构造的那个复杂的对象。Director就是我们的向导类，根据客户的需求生成产品A、产品B、产品C。\r\n      场景：麦当劳，汉堡和批萨，收银员就是向导类。以PHP为代码环境。\r\n[code]\r\n&lt;?php\r\n//麦当劳，抽象接口类\r\ninterface McDonald{\r\n    public function yuanLiao();\r\n    public function nieXingZhuang();\r\n    public function jiaRe();\r\n}\r\n//汉堡，就是产品A类\r\nclass Hamburger implements McDonald{\r\n    public function yuanLiao(){\r\n        echo ''采购原料：面+肉+生菜+酱'';\r\n        $this-&gt;separate();\r\n    }\r\n    public function nieXingZhuang(){\r\n        echo ''捏成蓬松的圆球形状'';\r\n        $this-&gt;separate();\r\n    }\r\n    public function jiaRe(){\r\n        echo ''加热10分种'';\r\n        $this-&gt;separate();\r\n    }\r\n    private function separate(){\r\n        echo ''&lt;br&gt;'';\r\n    }\r\n}\r\n//薯条，就是产品B类\r\nclass FrenchFries implements McDonald{\r\n    public function yuanLiao(){\r\n        echo ''采购原料：土豆'';\r\n        $this-&gt;separate();\r\n    }\r\n    public function nieXingZhuang(){\r\n        echo ''切成细长条'';\r\n        $this-&gt;separate();\r\n    }\r\n    public function jiaRe(){\r\n        echo ''加热15分种'';\r\n        $this-&gt;separate();\r\n    }\r\n    private function separate(){\r\n        echo ''&lt;br&gt;'';\r\n    }\r\n}\r\n//收银员，就是向导类\r\nclass Cashier{\r\n    public function createProduct($productObj){\r\n        $productObj-&gt;yuanLiao();\r\n        $productObj-&gt;nieXingZhuang();\r\n        $productObj-&gt;jiaRe();\r\n        return ''制作完成，可以上桌了'';\r\n    }\r\n}\r\n//客户端/接口\r\n$cashier = new Cashier();\r\n$cashier-&gt;createProduct(new Hamburger());\r\n$cashier-&gt;createProduct(new FrenchFries());\r\n?&gt;\r\n[/code]', 1398214218, 10, 10, 0),
(28, 8, '李轩Lane', '面向对象的洗礼：设计模式（十四）之观察者模式', '观察者模式，又叫做订阅-发布模式。当一个对象的改变需要同时改变多个对象的时候，可以使用法不这模式。设计模式中的观察者模式，就是为了解除类之间的耦合，使双方都依赖于抽象而不是依赖于具体。在实际生活中，比如我们更换了手机号，需要通知大家的时候，我们就是主题，或者通知者，而需要通知的人就是观察者列表，一条短信的群发告诉大家，就是观察者模式的应用。', '观察者模式_设计模式_设计模式之观察者模式', '观察者模式，又叫做订阅-发布模式。当一个对象的改变需要同时改变多个对象的时候，可以使用法不这模式。设计模式中的观察者模式，就是为了解除类之间的耦合，使双方都依赖于抽象而不是依赖于具体。', '观察者模式,设计模式,设计模式之观察者模式', 'PHP|设计模式|观察者模式', 56, '观察者模式，又叫做订阅-发布模式。当一个对象的改变需要同时改变多个对象的时候，可以使用法不这模式。设计模式中的观察者模式，就是为了解除类之间的耦合，使双方都依赖于抽象而不是依赖于具体。在实际生活中，比如我们更换了手机号，需要通知大家的时候，我们就是主题，或者通知者，而需要通知的人就是观察者列表，一条短信的群发告诉大家，就是观察者模式的应用。\r\n[code]\r\n&lt;?php\r\n//主题者、通知者抽象类。\r\nabstract class Subject{\r\n	private $observerList = array();\r\n	public function add(&amp;$obj, $action){\r\n		$this-&gt;observerList[] = array(''obj''=&gt;$obj, ''action''=&gt;$action);\r\n	}\r\n	public function notice(){\r\n		foreach($this-&gt;observerList as $observer){\r\n			$obj = $observer[''obj''];\r\n			$action = $observer[''action''];\r\n			$obj-&gt;$action;\r\n		}\r\n	}\r\n}\r\n//具体的通知者\r\nclass I extends Subject{\r\n	private $status;\r\n	public function getStatus(){\r\n		return $this-&gt;status;\r\n	}\r\n	public function setStatus($status){\r\n		$this-&gt;status = $status;\r\n	}\r\n}\r\n//观者者抽象类\r\nabstract class Observer{\r\n	public function sendSms(){\r\n	\r\n	}\r\n}\r\n//具体的观察者\r\nclass ConcreteObserver extends Observer{\r\n	private $name;\r\n	private $status;\r\n	private $objSubject;\r\n	public function __construct($name, $objSubject){\r\n		$this-&gt;name = $name;\r\n		$this-&gt;objSubject = $objSubject;\r\n	}\r\n	public function sendSms(){\r\n		$status = $this-&gt;objSubject-&gt;getStatus();\r\n		echo ''观察者''.$this-&gt;name.''收到的状态是''.$status.''&lt;br&gt;'';\r\n	}\r\n}\r\n//客户端/接口\r\n$i = new I();\r\n$i-&gt;setStatus(''更换手机号码了。'');\r\n$friend1 = new ConcreteObserver(''小明'', $i);\r\n$friend2 = new ConcreteObserver(''小红'', $i);\r\n$friend3 = new ConcreteObserver(''小黄'', $i);\r\n$i-&gt;add($friend1, ''sendSms'');\r\n$i-&gt;add($friend2, ''sendSms'');\r\n$i-&gt;add($friend3, ''sendSms'');\r\n$i-&gt;notice();\r\n?&gt;\r\n[/code]', 1398261969, 10, 14, 0),
(29, 8, '李轩Lane', '面向对象的洗礼：设计模式（十五）之抽象工厂模式', '抽象工厂模式，是工厂方法模式的演变，而工厂方法模式，是简单工厂模式的进化。抛弃了应用的条件控制语句，无论是switch还是if-ifelse。是设计模式的一种。抽线工厂模式来自于方法模式和简单工厂模式的进化与整合，其实，我已经要疯了，23种设计模式，现在已经出现了三种工厂模式。', '抽象工厂模式_设计模式_设计模式之抽象工厂模式', '抽象工厂模式，是工厂方法模式的演变，而工厂方法模式，是简单工厂模式的进化。抛弃了应用的条件控制语句，无论是switch还是if-ifelse。是设计模式的一种。', '抽象工厂模式,设计模式,设计模式之抽象工厂模式', 'PHP|设计模式|抽象工厂模式', 45, '抽象工厂模式，是工厂方法模式的演变，而工厂方法模式，是简单工厂模式的进化。抛弃了应用的条件控制语句，无论是switch还是if-ifelse。是设计模式的一种。\r\n    抽线工厂模式来自于方法模式和简单工厂模式的进化与整合，其实，我已经要疯了，23种设计模式，现在已经出现了三种工厂模式。\r\n    抽象工厂模式：提供一个创建一系列相关的、相互依赖的对象接口，而无需指定他们的具体类。\r\n    对于面向过程的编程，以及套在class里的面向对象的编程，修改起来是大批量的，是非常丑陋的。我常常告诫自己，编程是一门艺术，每个程序员都是艺术家，写出优美的，有艺术感的代码，并且是高效的，低成本的，这就是编程之美！\r\n    场景：原本是mysql，现在要换成oracle。以PHP为代码环境。现在有两张表，一个是用户表user，一个是公司表company。\r\n[code]\r\n&lt;?php\r\nclass Db{\r\n    private static $dbName = ''mysql'';\r\n    public static function createUserDbObj(){\r\n        $className = self::$dbName . ''UserDbModel'';\r\n        return new $className();\r\n    }\r\n    public static function createCompanyDbObj(){\r\n        $className = self::$dbName . ''CompanyDbModel'';\r\n        return new $className();\r\n    }\r\n}\r\ninterface User{\r\n    public function get();\r\n    public function set();\r\n}\r\nclass mysqlUserDbModel implements User{\r\n    public function get(){\r\n        echo ''从Mysql中查找用户记录&lt;br&gt;'';\r\n    }\r\n    public function set(){\r\n        echo ''从Mysql中添加用户记录&lt;br&gt;'';\r\n    }\r\n}\r\nclass oracleUserDbModel implements User{\r\n    public function get(){\r\n        echo ''从Oracle中查找用户记录&lt;br&gt;'';\r\n    }\r\n    public function set(){\r\n        echo ''从Oracle中添加用户记录&lt;br&gt;'';\r\n    }\r\n}\r\ninterface Company{\r\n    public function get();\r\n    public function set();\r\n}\r\nclass mysqlCompanyDbModel implements User{\r\n    public function get(){\r\n        echo ''从Mysql中查找公司记录&lt;br&gt;'';\r\n    }\r\n    public function set(){\r\n        echo ''从Mysql中添加公司记录&lt;br&gt;'';\r\n    }\r\n}\r\nclass oracleCompanyDbModel implements User{\r\n    public function get(){\r\n        echo ''从Oracle中查找公司记录&lt;br&gt;'';\r\n    }\r\n    public function set(){\r\n        echo ''从Oracle中添加公司记录&lt;br&gt;'';\r\n    }\r\n}\r\n//客户端/接口\r\n$userDbObj = Db::createUserDbObj();\r\n$companyDbObj = Db::createCompanyDbObj();\r\n$userDbObj-&gt;get();\r\n$userDbObj-&gt;set();\r\n$companyDbObj-&gt;get();\r\n$companyDbObj-&gt;set();\r\n[/code]\r\n    现在代码的方式，是把选择数据库给写死到程序中了（Db类）， 我们可以以更加灵活的方式，比如：\r\n    1、配置\r\n[code]\r\nconfig.php\r\n&lt;?php\r\ndefine(''DB_NAME'', ''mysql'');\r\n[/code]\r\n    2、文件\r\n[code]\r\n$f = fopen(''config'', ''r'');\r\n$config = '''';\r\nwhile(!feof($f)){\r\n    $config .= fgets($f);\r\n    $config .= '' '';\r\n}\r\n//----------------我是分割线-----------\r\n$config = file_get_contents(''config'');\r\n//-------------------------------------------\r\n//$config = ''dbtype:mysql|username:root|password:root'';\r\n$config = explode(''|'', $config);\r\nforeach($config as $k=&gt;$c){\r\n    $data = explode('':'', $c);\r\n    unset($config[$k]);\r\n    $config[$data[0]] = $data[1];\r\n}\r\nprint_r($config);\r\n[/code]\r\n    个人认为：这种方式的数据库应用代码设计，仍旧是很繁琐的，每增加一张表，需要增加各个类型的数据库类各一个。所以，本例仅仅是为了演示说明抽象工厂模式。', 1398345637, 8, 7, 0),
(30, 8, '李轩Lane', '面向对象的洗礼：设计模式（十六）之状态模式', '状态模式是根据状态来执行不同的功能，通常以switch和if-ifelse来逻辑判断。面向对象设计，它的目的就是希望代码能够根据责任、功能来进行分解，不再是一大长串。状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂的时候，把状态的判断转移到表示不同状态的一系列类当中，把复杂的判断逻辑简化。', '状态模式_设计模式_设计模式之状态模式', '态模式是根据状态来执行不同的功能，通常以switch和if-ifelse来逻辑判断。状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂的时候，把状态的判断转移到表示不同状态的一系列类当中，把复杂的判断逻辑简化。', '状态模式,设计模式,设计模式之状态模式', 'PHP|设计模式|状态模式', 52, '状态模式是根据状态来执行不同的功能，通常以switch和if-ifelse来逻辑判断。面向对象设计，它的目的就是希望代码能够根据责任、功能来进行分解，不再是一大长串。状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂的时候，把状态的判断转移到表示不同状态的一系列类当中，把复杂的判断逻辑简化。\r\n    状态模式：当一个对象内在的状态改变时允许改变他的行为，这个对象看起来像是改变了其类。\r\n    当一个对象运行时，该执行什么方法，是取决于它的状态的时候，我们不用臃肿的条件判断语句，而是使用状态模式。\r\n    场景：人的行为，早上吃早饭，然后走路，上班，吃午饭，上班，走路，回家吃晚饭，睡觉。用条件控制来实现，if(time()==8点){ 吃早饭 }else if()....看看GoF的状态模式如何实现人的行为。以PHP为代码环境。\r\n[code]\r\n&lt;?php\r\nclass Person{\r\n    private $state;\r\n    private $time;\r\n    public function __construct(){\r\n        $this-&gt;state = new Breakfast();\r\n    }\r\n    public function getTime(){\r\n        return $this-&gt;time;\r\n    }\r\n    public function setTime($time){\r\n        $this-&gt;time = $time;\r\n    }\r\n    public function getState(){\r\n        return $this-&gt;state;\r\n    }\r\n    public function setState($state){\r\n        $this-&gt;state = $state;\r\n    }\r\n    public function behavior(){\r\n        $this-&gt;state-&gt;behavior($this);\r\n    }\r\n}\r\nclass Breakfast{\r\n    public function behavior($personObj){\r\n        if($personObj-&gt;getTime() &lt; 8){\r\n            echo ''吃早餐&lt;br&gt;'';\r\n        }else{\r\n            $personObj-&gt;setState(new Walk());\r\n            $personObj-&gt;behavior();\r\n        }\r\n    }\r\n}\r\nclass Walk{\r\n    public function behavior($personObj){\r\n        if($personObj-&gt;getTime() &lt; 9 || ($personObj-&gt;getTime() &gt; 18 &amp;&amp; $personObj-&gt;getTime() &lt; 19)){\r\n            echo ''走路&lt;br&gt;'';\r\n        }else{\r\n            if($personObj-&gt;getTime() &gt; 9 &amp;&amp; $personObj-&gt;getTime() &lt; 18){\r\n                $personObj-&gt;setState(new Work());\r\n                $personObj-&gt;behavior();\r\n            }else{\r\n                $personObj-&gt;setState(new Dinner());\r\n                $personObj-&gt;behavior();\r\n            }\r\n        }\r\n    }\r\n}\r\nclass Work{\r\n    public function behavior($personObj){\r\n        if($personObj-&gt;getTime() &lt; 12 || ($personObj-&gt;getTime() &gt; 13 &amp;&amp; $personObj-&gt;getTime() &lt; 18)){\r\n            echo ''工作&lt;br&gt;'';\r\n        }else{\r\n            if($personObj-&gt;getTime() &lt; 13){\r\n                $personObj-&gt;setState(new Lunch());\r\n                $personObj-&gt;behavior();\r\n            }else{\r\n                $personObj-&gt;setState(new Walk());\r\n                $personObj-&gt;behavior();\r\n            }\r\n        }\r\n    }\r\n}\r\nclass Lunch{\r\n    public function behavior($personObj){\r\n        if($personObj-&gt;getTime() &lt; 13){\r\n            echo ''吃午餐&lt;br&gt;'';\r\n        }else{\r\n            $personObj-&gt;setState(new work());\r\n            $personObj-&gt;behavior();\r\n        }\r\n    }\r\n}\r\nclass Dinner{\r\n    public function behavior($personObj){\r\n        if($personObj-&gt;getTime() &lt; 20){\r\n            echo ''吃晚餐&lt;br&gt;'';\r\n        }else{\r\n            $personObj-&gt;setState(new Sleep());\r\n            $personObj-&gt;behavior();\r\n        }\r\n    }\r\n}\r\nclass Sleep{\r\n    public function behavior($personObj){\r\n        echo ''睡觉&lt;br&gt;'';\r\n        exit;\r\n    }\r\n}\r\n//客户端/接口\r\n$personObj = new Person();\r\n//时间表\r\n$timeList = array(7, 8.5, 10, 12.5, 15, 18.5, 19.5);\r\nforeach($timeList as $time){\r\n    $personObj-&gt;setTime($time);\r\n    $personObj-&gt;behavior();\r\n}\r\n[/code]', 1398348266, 11, 10, 0),
(31, 8, '李轩Lane', '面向对象的洗礼：设计模式（十七）之适配器模式', '适配器模式，尽管是一种常见的设计模式，但是有点亡羊补牢的感觉。不是首选的设计模式。适配器模式是连接两个类的中间件，当一个类想要调用某一个类的接口时，发现尽管这个类的接口可以实现想要的功能，但是却不能用。比如因为格式的问题等等，这时候需要一个中间件来充当转换器，这就是适配器模式。', '适配器模式_设计模式_设计模式之适配器模式', '适配器模式，尽管是一种常见的设计模式，但是有点亡羊补牢的感觉。不是首选的设计模式。适配器模式是连接两个类的中间件，当一个类想要调用某一个类的接口时，发现尽管这个类的接口可以实现想要的功能，但是却不能用。比如因为格式的问题等等，这时候需要一个中间件来充当转换器，这就是适配器模式。', '适配器模式,设计模式,设计模式之适配器模式', 'PHP|设计模式|适配器模式', 49, '适配器模式，尽管是一种常见的设计模式，但是有点亡羊补牢的感觉。不是首选的设计模式。适配器模式是连接两个类的中间件，当一个类想要调用某一个类的接口时，发现尽管这个类的接口可以实现想要的功能，但是却不能用。比如因为格式的问题等等，这时候需要一个中间件来充当转换器，这就是适配器模式。\r\n    适配器模式：适配器模式（有时候也称包装样式或者包装）将一个类的接口适配成用户所期待的。一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。（本段摘自百度百科（因为想找个不是我的白话文的定义-.-））。\r\n    实际生活中，比如我们买美版、欧版的电子产品，人家很多国家时110V电压，而我们国家时220V电压，所以需要一个电源适配器，来转换电压以便能够再国内的电网环境中安全的使用。\r\n    下面的例子是一个假设，由于历史原因或者开发不规范的原因，时有些定义并不一致。比如已经离职的同事A定义了商品字符串为id|num^id|num，而另一个同事B在开发时使用的是id@num#id@num，使得第三个同事C在开发时不能直接调用A和B同事的写好的现成类的方法，需要写一个类做为中间件来转换它。使的他们兼容。开放 - 封闭原则告诉我们，不要去修改人家的类，而是以扩展的方式去改变它。因此适配器模式诞生了。以PHP为代码环境：\r\n[code]\r\n&lt;?php\r\n//id|num^id|num\r\nclass ColleagueA{\r\n    public static function getString(){\r\n        //读取mysql略\r\n        return ''1|1^2|1'';\r\n    }\r\n    public static function setString($str){\r\n        echo ''写进mysql:'' . $str;\r\n    }\r\n}\r\n//id@num#id@num\r\nclass ColleagueB{\r\n    public static function getString(){\r\n        //读取mysql略\r\n        return ''1@1#2@1'';\r\n    }\r\n    public static function setString($str){\r\n        echo ''写进mysql:'' . $str;\r\n    }\r\n}\r\n//适配器\r\nclass Adaptation{\r\n    public static function changeAToB($str){\r\n        $data = array();\r\n        $arr = explode(''^'', $str);\r\n        foreach($arr as $a){\r\n            $data[] = explode(''|'', $a);\r\n        }\r\n        $arr = $data;\r\n        $data = '''';\r\n        foreach($arr as $a){\r\n            $data[] = implode(''@'', $a);\r\n        }\r\n        return implode(''#'', $data);\r\n    }\r\n    public static function changeBToA($str){\r\n        $data = array();\r\n        $arr = explode(''#'', $str);\r\n        foreach($arr as $a){\r\n            $data[] = explode(''@'', $a);\r\n        }\r\n        $arr = $data;\r\n        $data = '''';\r\n        foreach($arr as $a){\r\n            $data[] = implode(''|'', $a);\r\n        }\r\n        return implode(''^'', $data);\r\n    }\r\n}\r\n//客户端/接口\r\n$stringFromA = ColleagueA::getString();\r\n$stringFromAdaptation = Adaptation::changeAToB($stringFromA);\r\nColleagueB::setString($stringFromAdaptation);\r\necho ''&lt;br&gt;'';\r\n$stringFromB = ColleagueB::getString();\r\n$stringFromAdaptation = Adaptation::changeBToA($stringFromB);\r\nColleagueA::setString($stringFromAdaptation);\r\n[/code]\r\n\r\nPs：严格执行开发规范，开发前该抽象的抽象，该封装的封装，比到最后没办法了用这个适配器模式强的多。\r\n    适配器模式，一种亡羊补牢的模式，食之无味，弃之可惜。', 1398386259, 12, 9, 0);
INSERT INTO `info_article` (`id`, `mid`, `author`, `title`, `description`, `seo_title`, `seo_description`, `seo_keywords`, `tag`, `clicks`, `content`, `ctime`, `good_num`, `bad_num`, `recommend_type`) VALUES
(32, 8, '李轩Lane', '面向对象的洗礼：设计模式（十八）之备忘录模式', '备忘录模式，顾名思义，记录某种数据，在需要的时候释放出来。在游戏中，存档，读档就是备忘录模式。被Boss打死后复活，数据回复到打Boss之前，也是设计模式中的备忘录模式。在但是在游戏中，角色类的功能不能带有存储旧状态数据和恢复旧状态数据的方法。把存储和读取的细节封装到一个新类中。职责分离。每个类超过一个功能，就需要考虑拆分了。这也是单一原则的体现。', '备忘录模式_设计模式_设计模式之备忘录模式', '备忘录模式，顾名思义，记录某种数据，在需要的时候释放出来。在游戏中，存档，读档就是备忘录模式。被Boss打死后复活，数据回复到打Boss之前，也是设计模式中的备忘录模式。', '备忘录模式,设计模式,设计模式之备忘录模式', 'PHP|设计模式|备忘录模式', 64, '备忘录模式，顾名思义，记录某种数据，在需要的时候释放出来。在游戏中，存档，读档就是备忘录模式。被Boss打死后复活，数据回复到打Boss之前，也是设计模式中的备忘录模式。在但是在游戏中，角色类的功能不能带有存储旧状态数据和恢复旧状态数据的方法。把存储和读取的细节封装到一个新类中。职责分离。每个类超过一个功能，就需要考虑拆分了。这也是单一原则的体现。\r\n    备忘录模式：在不破坏封装的前提下，捕获一个对象的内部属性数据，将这个状态保存在另一个类中，以便以后的恢复数据需求。\r\n    场景：EA知名游戏模拟人生The Sims，存档和读档。以PHP为代码环境来模拟场景。\r\n[code]\r\n&lt;?php\r\n//管理‘档案器的类’的类\r\nclass Archives{\r\n    private $memento;\r\n    public function get(){\r\n        return $this-&gt;memento;\r\n    }\r\n    public function set($mementoObj){\r\n        return $this-&gt;memento = $mementoObj;\r\n    }\r\n}\r\nclass Memento{\r\n    private $mementoData;\r\n    public function __construct($data){\r\n        $this-&gt;mementoData = $data;\r\n    }\r\n    public function get(){\r\n        return $this-&gt;mementoData;\r\n    }\r\n}\r\nclass GameRole{\r\n    private $money;\r\n    private $name;\r\n    public function setMoney($money){\r\n        $this-&gt;money = $money;\r\n    }\r\n    public function setName($name){\r\n        $this-&gt;name = $name;\r\n    }\r\n    public function getMoney(){\r\n        return $this-&gt;money;\r\n    }\r\n    public function getName(){\r\n        return $this-&gt;name;\r\n    }\r\n    public function setMemento(){\r\n        $data[''money''] = $this-&gt;money;\r\n        $data[''name''] = $this-&gt;name;\r\n        return new Memento($data);\r\n    }\r\n    public function getMemento($mementoObj){\r\n        $mementoData = $mementoObj-&gt;get();;\r\n        $this-&gt;money = $mementoData[''money''];\r\n        $this-&gt;name = $mementoData[''name''];\r\n    }\r\n    public function display(){\r\n        echo ''玩家'' . $this-&gt;name . ''家有家庭资产'' . $this-&gt;money . ''元&lt;br&gt;'';\r\n    }\r\n}\r\n//客户端/接口\r\n//游戏开始，小明家有100元\r\n$playObj = new GameRole();\r\n$playObj-&gt;setName(''小明'');\r\n$playObj-&gt;setMoney(100);\r\n$playObj-&gt;display();\r\n//存档\r\n$archivesObj = new Archives();\r\n$archivesObj-&gt;set($playObj-&gt;setMemento());\r\n//小明家做生意亏损了90元\r\n$playObj-&gt;setMoney(10);\r\n$playObj-&gt;display();\r\n//读档\r\n$playObj-&gt;getMemento($archivesObj-&gt;get());\r\n$playObj-&gt;display();\r\n[/code]\r\n优点：彻底封装了存档和读档的细节实现，完全不对外公开。备忘录类只有玩家类能够操作。对客户端和顶层外网接口完全细节封装和数据封闭。', 1398438254, 8, 10, 0),
(33, 8, '李轩Lane', '面向对象的洗礼：设计模式（十九）之组合模式', '组合模式告诉我们，对待部分和对待整体是一样的。整体和部分就是总部和分部的关系。使用设计模式中的组合模式，客户端不需要知道它调用的到底是整体的接口还是部分的接口。北京总公司为整体，下属有上海分公司，北京总公司财务，北京总公司人事。上海分公司下属有上海分公司财务，上海分公司财务。这就是整体与部分的关系，是组合模式的使用前提。需求中是体现部分和整体的结构时，用户不需要关心是在使用整体的对象还是单个对象而是使用统一的接口对象时，就可以考虑设计模式中的组合模式了。', '组合模式_设计模式_设计模式之组合模式', '组合模式告诉我们，对待部分和对待整体是一样的。整体和部分就是总部和分部的关系。使用设计模式中的组合模式，客户端不需要知道它调用的到底是整体的接口还是部分的接口。', '组合模式,设计模式,设计模式之组合模式', 'PHP|设计模式|组合模式', 82, '组合模式告诉我们，对待部分和对待整体是一样的。整体和部分就是总部和分部的关系。使用设计模式中的组合模式，客户端不需要知道它调用的到底是整体的接口还是部分的接口。北京总公司为整体，下属有上海分公司，北京总公司财务，北京总公司人事。上海分公司下属有上海分公司财务，上海分公司财务。这就是整体与部分的关系，是组合模式的使用前提。需求中是体现部分和整体的结构时，用户不需要关心是在使用整体的对象还是单个对象而是使用统一的接口对象时，就可以考虑设计模式中的组合模式了。\r\n    组合模式：可以用整体-部分的结构来表示一个对象的结构层次。使用组合模式使得用户对组合对象和单个对象没有不同的感受。\r\n    场景：北京总公司，上海分公司，北京财务部，上海财务部的公司结构。以PHP为代码环境。代码仅仅为了说明组合模式，并不推荐实际开发中的使用。\r\n[code]\r\n&lt;?php\r\n//具体的公司\r\nclass ConcreteCompany{\r\n    public $name;\r\n    private $companyList = array();\r\n    public function __construct($name){\r\n        $this-&gt;name = $name;\r\n    }\r\n    public function add($obj){\r\n        $this-&gt;companyList[] = $obj;\r\n    }\r\n    public function display(){\r\n        foreach($this-&gt;companyList as $company){\r\n            echo ''--'';\r\n            echo $company-&gt;name;\r\n            echo ''&lt;br&gt;'';\r\n            if(!empty($company-&gt;companyList)){\r\n                echo ''--'';\r\n                $company-&gt;display();\r\n            }\r\n        }\r\n    }\r\n}\r\nclass Department{\r\n    public $name;\r\n    public function __construct($name){\r\n        $this-&gt;name = $name;\r\n    }\r\n    public function add(){\r\n        echo ''已经是最小分类了，不能再细分了&lt;br&gt;'';\r\n    }\r\n    public function display(){\r\n        echo ''--'';\r\n        echo $this-&gt;name;\r\n        echo ''&lt;br&gt;'';\r\n    }\r\n}\r\n//客户端/接口\r\n$headCompany = new ConcreteCompany(''北京总公司'');\r\n$headCompany-&gt;add(new Department(''北京总公司财务部''));\r\n$headCompany-&gt;add(new Department(''北京总公司人事部''));\r\n\r\n$concreteCompany1 = new ConcreteCompany(''上海分公司'');\r\n$concreteCompany1-&gt;add(new Department(''上海分公司财务部''));\r\n$concreteCompany1-&gt;add(new Department(''上海分公司人事部''));\r\n$headCompany-&gt;add($concreteCompany1);\r\n\r\n$concreteCompany2 = new ConcreteCompany(''青岛分公司'');\r\n$concreteCompany2-&gt;add(new Department(''青岛分公司财务部''));\r\n$concreteCompany2-&gt;add(new Department(''青岛分公司人事部''));\r\n$headCompany-&gt;add($concreteCompany2);\r\n\r\necho ''全公司组织架构：&lt;br&gt;'';\r\n$headCompany-&gt;display();\r\necho ''&lt;br&gt;&lt;br&gt;上海分公司组织架构：&lt;br&gt;'';\r\n$concreteCompany1-&gt;display();\r\necho ''&lt;br&gt;&lt;br&gt;上海分公司组织架构：&lt;br&gt;'';\r\n$concreteCompany2-&gt;display();\r\n[/code]', 1398441494, 12, 6, 0),
(34, 8, '李轩Lane', '面向对象的洗礼：设计模式（二十）之迭代器模式', '迭代器模式，将一个列表从头到尾或者从尾到头进行一次遍历。迭代器模式是被提名要求废除的一种设计模式。因为很多的高级语言，如PHP，Python，JAVA等，都已经拥有了foreach。迭代器模式用来访问一个列表的第一个，最后一个，或者某一个的下一个。', '迭代器模式_设计模式_设计模式之迭代器模式', '迭代器模式，将一个列表从头到尾或者从尾到头进行一次遍历。迭代器模式是被提名要求废除的一种设计模式。', '迭代器模式,设计模式,设计模式之迭代器模式', 'PHP|设计模式|迭代器模式', 93, '迭代器模式，将一个列表从头到尾或者从尾到头进行一次遍历。迭代器模式是被提名要求废除的一种设计模式。因为很多的高级语言，如PHP，Python，JAVA等，都已经拥有了foreach。\r\n    迭代器模式：提供一种方法顺序，来访问一个聚合中的各个元素，而不暴露该对象的内部表示。\r\n    迭代器模式用来访问一个列表的第一个，最后一个，或者某一个的下一个。\r\n    以PHP为代码环境模拟一下迭代器模式的思想。抽象一个Iterator类的理由是有可能是正序，有可能倒序查找。\r\n[code]\r\n&lt;?php\r\nabstract class Iterator{\r\n    public function first(){\r\n\r\n    }\r\n    public function last(){\r\n\r\n    }\r\n}\r\n//正序\r\nclass PositiveOrder extends Iterator{\r\n    private $list;\r\n    private $listTmp;\r\n    public function __construct($list){\r\n        $this-&gt;list = $list;\r\n        $this-&gt;listTmp = array_values($list);\r\n    }\r\n    public function first(){\r\n        return $this-&gt;listTmp[0];\r\n    }\r\n    public function last(){\r\n        return $this-&gt;listTmp[(count($this-&gt;listTmp)-1)];\r\n    }\r\n}\r\n//倒序\r\nclass ReverseOrder extends Iterator{\r\n    private $list;\r\n    private $listTmp;\r\n    public function __construct($list){\r\n        $this-&gt;list = $list;\r\n        $this-&gt;listTmp = array_values($list);\r\n    }\r\n    public function first(){\r\n        return $this-&gt;listTmp[(count($this-&gt;listTmp)-1)];\r\n    }\r\n    public function last(){\r\n        return $this-&gt;listTmp[0];\r\n    }\r\n}\r\n[/code]\r\n    我们还可以去模拟获取某个元素的下一个元素等。\r\n    在PHP中，活跃社区的各个开发者都在为PHP的明天做贡献，为我们提供了已经封装好的函数，用来操作PHP数组的内部指针。\r\n[code]\r\nnext();    定位指针到当前位置的后一个\r\nprev();       定位指针到当前位置的前一个\r\nreset();   重置指针到数组的开始\r\nend();     定位指针到数组的最后\r\ncurrent(); 取得当前指针位置的值\r\nkey();     取得当前指针位置的键\r\n[/code]\r\n    使用示例：\r\n[code]\r\n&lt;?php\r\n$arr=array(&quot;php&quot;=&gt;&quot;脚本&quot;,&quot;python&quot;=&gt;&quot;脚本&quot;,&quot;mysql&quot;=&gt;&quot;数据库&quot;);\r\nwhile(list($key,$value)=each($arr)){\r\n    echo $key.''============&gt;''.$value.''&lt;br&gt;'';\r\n}\r\n/**\r\n * 输出结果\r\n * php============&gt;脚本\r\n * python============&gt;脚本\r\n * mysql============&gt;数据库\r\n */\r\nreset($arr);\r\nwhile(list($key,$value)=each($arr)){\r\n    echo $key.''============&gt;''.$value.''&lt;br&gt;'';\r\n}\r\n/**\r\n * 输出结果\r\n * php============&gt;脚本\r\n * python============&gt;脚本\r\n * mysql============&gt;数据库\r\n */\r\nreset($arr);\r\nnext($arr);\r\nwhile(list($key,$value)=each($arr)){\r\n    echo $key.''============&gt;''.$value.''&lt;br&gt;'';\r\n}\r\n/**\r\n * 输出结果\r\n * python============&gt;脚本\r\n * mysql============&gt;数据库\r\n */\r\nend($arr);\r\necho current($arr).''=============&gt;''.key($arr).''&lt;br&gt;'';\r\n/**\r\n * 输出结果\r\n * mysql============&gt;数据库\r\n */\r\nprev($arr);\r\necho current($arr).''=========&gt;''.key($arr).''&lt;br&gt;'';\r\n/**\r\n * 输出结果\r\n * python============&gt;脚本\r\n */\r\n[/code]', 1398498396, 10, 8, 0),
(35, 8, '李轩Lane', '面向对象的洗礼：设计模式（二十一）之单例模式', '单例模式，顾名思义，单个的实例，就是对某个对象，只new一次。单例模式是设计模式常见的一种，用来创建封装好的类的唯一一个实例，这样一来，可以严格控制客户怎么样访问它以及何时访问它，对唯一实例的受控访问。', '单例模式_设计模式_设计模式之单例模式', '单例模式，顾名思义，单个的实例，就是对某个对象，只new一次。单例模式是设计模式常见的一种，用来创建封装好的类的唯一一个实例，这样一来，可以严格控制客户怎么样访问它以及何时访问它，对唯一实例的受控访问。', '单例模式,设计模式,设计模式之单例模式', 'PHP|设计模式|单例模式', 67, '单例模式，顾名思义，单个的实例，就是对某个对象，只new一次。单例模式是设计模式常见的一种，用来创建封装好的类的唯一一个实例，这样一来，可以严格控制客户怎么样访问它以及何时访问它，对唯一实例的受控访问。\r\n    单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点。\r\n    单例模式如何防止一个类被多次new呢？首先，每个类都有一个构造函数，即使没有显式的声明，也是以public存在的，将构造函数设为private。其次，让该类保存实例化后的对象，并提供一个对外的接口。\r\n    示例场景：mysql中user表。以PHP为代码环境，来模拟设计模式中的单例模式。\r\n[code]\r\n&lt;?php\r\nclass UserMysqlModel{\r\n    public function get(){\r\n        echo ''获取user表的数据&lt;br&gt;'';\r\n    }\r\n    public function set(){\r\n        echo ''写入user表的数据&lt;br&gt;'';\r\n    }\r\n    public function edit(){\r\n        echo ''修改user表的数据&lt;br&gt;'';\r\n    }\r\n    public function del(){\r\n        echo ''删除user表的数据&lt;br&gt;'';\r\n    }\r\n}\r\nclass UserBusiness{\r\n    private static $userMysqlModelObj = '''';\r\n    private function __construct(){\r\n\r\n    }\r\n    public static function getInstance(){\r\n        if(empty(self::$userMysqlModelObj)){\r\n            self::$userMysqlModelObj = new UserMysqlModel();\r\n        }\r\n        return self::$userMysqlModelObj;\r\n    }\r\n}\r\n//客户端/接口\r\n$userBusinessObj = UserBusiness::getInstance()-&gt;get();\r\n$userBusinessObj = UserBusiness::getInstance()-&gt;set();\r\n$userBusinessObj = UserBusiness::getInstance()-&gt;edit();\r\n$userBusinessObj = UserBusiness::getInstance()-&gt;del();\r\n[/code]', 1398499693, 8, 9, 0),
(36, 8, '李轩Lane', '面向对象的洗礼：设计模式（二十二）之桥接模式', '桥接模式，就是实现系统可能有多角度分类，每一种分类都有可能变化，可能增加或减少。那么，就把这种多角度分离出来让他们独自变化，减少它们之间的耦合。', '桥接模式_设计模式_设计模式之桥接模式', '桥接模式，就是实现系统可能有多角度分类，每一种分类都有可能变化，可能增加或减少。那么，就把这种多角度分离出来让他们独自变化，减少它们之间的耦合。', '桥接模式,设计模式,设计模式之桥接模式', 'PHP|设计模式|桥接模式', 66, '桥接模式，就是实现系统可能有多角度分类，每一种分类都有可能变化，可能增加或减少。那么，就把这种多角度分离出来让他们独自变化，减少它们之间的耦合。\r\n    比如，现在的智能手机，安卓的ipk文件就不能安装在苹果的ios系统上。分类一（按照手机操作系统来分）：手机系统分为安卓和IOS，安卓的软件分为游戏、音乐等，IOS的软件也分为游戏、音乐等。分类二（按照软件来分）：软件分为游戏和音乐，游戏分为安卓游戏和IOS游戏，音乐也分为安卓音乐和IOS音乐。\r\n    思考：增加一个手机系统，如Windos 8。那么，分类就变了。如下：分类一（按照手机操作系统来分）：手机系统分为安卓和IOS和Windows 8，安卓的软件分为游戏、音乐等，IOS的软件也分为游戏、音乐等，Windows 8的软件也分为游戏和音乐等。分类二（按照软件来分）：软件分为游戏和音乐，游戏分为安卓游戏和IOS游戏和Windows 8游戏，音乐也分为安卓音乐和IOS音乐和Windows 8音乐。\r\n    这种分类的弊病非常明显，如果要增加一个手机的操作系统，相应的需要改变原有分类，增加大量的class文件。操作系统和手机软件的分类是高强度耦合。\r\n    在面向对象的变成里，耦合度越高的越不利于复用，设计模式的重点就是降低耦合，减少复制-粘贴的编码模式。在这个例子中，引出了一种设计模式，叫做桥接模式。\r\n    桥接模式：将抽象的部分与它的实现分离，使他们可以独立变化。\r\n    所谓的实现，就是抽象类和派生类用来实现自己的对象。白话文就是：就是实现系统可能有多角度分类，每一种分类都有可能变化，可能增加或减少。那么，就把这种多角度分离出来让他们独自变化，减少它们之间的耦合。\r\n    桥接模式的分类：手机操作系统分为安卓和IOS，手机软件分为游戏和音乐。操作系统和软件相互独立，没有强的明显关系，操作系统和手机软件不进行分类关联，它们俩的真实关系请继续往后看。\r\n    那么，耦合度降低了，增加windows8只需要在操作系统分类下增加一个windows8，软件则不需要变化。\r\n    再引入一个原则，合成-聚合复用原则：尽量使用合成-聚合，尽量不要使用类的继承。\r\n    聚合是弱拥有关系，A可以包含B，但是B不是A的一部分。合成是强拥有关系，严格的部分和整体，两者拥有相同的生命周期。\r\n    大雁的翅膀和大雁本身是合成关系，生命周期一样，是强拥有关系。大雁和雁群是聚合关系，大雁只属于一个雁群，但是雁群不仅仅只有这一个大雁。（本例摘自《大话设计模式》）\r\n    回到上一个话题，在桥接模式的分类下，手机操作系统和手机软件之间的关系，就是聚合关系，弱的关系，才可以降低耦合。\r\n    以PHP为代码环境，说明手机的例子。\r\n[code]\r\n&lt;?php\r\nabstract class Soft{\r\n    public function run(){}\r\n}\r\nclass Game extends Soft{\r\n    public function run(){\r\n        echo ''手机游戏正在运行...&lt;br&gt;'';\r\n    }\r\n}\r\nclass Mp3 extends Soft{\r\n    public function run(){\r\n        echo ''手机音乐播放器正在运行...&lt;br&gt;'';\r\n    }\r\n}\r\nabstract class OS{\r\n    protected $softObj;\r\n    public function setSoftObj($softObj){\r\n        $this-&gt;softObj = $softObj;\r\n    }\r\n    public function run(){}\r\n}\r\nclass Ios extends OS{\r\n    public function run(){\r\n        $this-&gt;softObj-&gt;run();\r\n    }\r\n}\r\nclass Android extends OS{\r\n    public function run(){\r\n        $this-&gt;softObj-&gt;run();\r\n    }\r\n}\r\n//客户端/接口\r\necho ''购买了Iphone一台，搭载IOS操作系统&lt;br&gt;'';\r\n$iphone = new Ios();\r\n$iphone-&gt;setSoftObj(new Game());\r\n$iphone-&gt;run();\r\n$iphone-&gt;setSoftObj(new Mp3());\r\n$iphone-&gt;run();\r\n\r\necho ''购买了三星一台，搭载安卓操作系统&lt;br&gt;'';\r\n$samsung = new Ios();\r\n$samsung-&gt;setSoftObj(new Game());\r\n$samsung-&gt;run();\r\n$samsung-&gt;setSoftObj(new Mp3());\r\n$samsung-&gt;run();\r\n[/code]', 1398579192, 10, 11, 0),
(37, 8, '李轩Lane', '面向对象的洗礼：设计模式（二十三）之命令模式', '命令模式解决了行为者与请求者过于紧耦合。即设计模式之命令模式将一个请求指定一个响应者的模式进行了解耦化。命令模式：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，请求排队或记录日志已经执行可撤销的操作。', '命令模式_设计模式_设计模式之命令模式', '命令模式解决了行为者与请求者过于紧耦合。即设计模式之命令模式将一个请求指定一个响应者的模式进行了解耦化。', '命令模式,设计模式,设计模式之命令模式', 'PHP|设计模式|命令模式', 53, '命令模式解决了行为者与请求者过于紧耦合。即命令模式将一个请求指定一个响应者的模式进行了解耦化。\r\n    命令模式：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，请求排队或记录日志已经执行可撤销的操作。\r\n    命令模式的优点：第一、比较容易的设计一个队列；第二、比较容易的命令写入日志；第三、允许接收请求的一方决定是否要否决请求；第四、比较容易的实现请求的撤销和重做；第五、增加新命令不影响其他类；第六、把请求者和响应者分离。\r\n    场景：淘宝下订单，紧耦合就是点击下单按钮，请求直接发送给响应者。使用设计模式的命令模式进行解耦操作，就是点击下订单，请求发送给一个中央订单处理系统，然后由中央订单处理系统这个中间件分发给淘宝订单中心、天猫订单中心、聚划算订单中心等不同的操作，同时添加日志记录等。以PHP为代码环境来说明命令模式。\r\n[code]\r\n&lt;?php\r\nclass OrderCenter{\r\n    public $orderList;\r\n    public function setOrder($order){\r\n        //没有库存\r\n        $isStock = true;\r\n        //秒杀活动没有开始\r\n        $isActivityTime = true;\r\n        if(!$isStock &amp;&amp; !$isActivityTime){\r\n            exit(''活动没开始，即将跳转回之前的页面'');\r\n        }else{\r\n            $this-&gt;orderList[] = $order;\r\n        }\r\n    }\r\n    public function cancelOrder(){\r\n\r\n    }\r\n    //假定是一个队列服务\r\n    public function queue(){\r\n        foreach($this-&gt;orderList as $key=&gt;$order){\r\n            echo ''订单处理成功&lt;br&gt;'';\r\n            $order-&gt;setOrder();\r\n            unset($this-&gt;orderList[$key]);\r\n        }\r\n    }\r\n}\r\nclass Order{\r\n    public function buyClothes(){\r\n        echo ''购买衣服成功&lt;br&gt;'';\r\n    }\r\n    public function buyShoes(){\r\n        echo ''购买鞋子成功&lt;br&gt;'';\r\n    }\r\n}\r\nabstract class Command{\r\n    public $request;\r\n    public function __constrcut($requestObj){\r\n        $this-&gt;request = $requestObj;\r\n    }\r\n    public function setOrder(){}\r\n}\r\nclass TaoBao extends Command{\r\n    public function __construct($requestObj){\r\n        parent::__constrcut($requestObj);\r\n    }\r\n    public function setOrder(){\r\n        echo ''淘宝订单：&lt;br&gt;'';\r\n        $this-&gt;request-&gt;buyClothes();\r\n        $this-&gt;request-&gt;buyShoes();\r\n    }\r\n}\r\nclass Tmall extends Command{\r\n    public function __construct($requestObj){\r\n        parent::__constrcut($requestObj);\r\n    }\r\n    public function setOrder(){\r\n        echo ''天猫订单：&lt;br&gt;'';\r\n        $this-&gt;request-&gt;buyClothes();\r\n        $this-&gt;request-&gt;buyShoes();\r\n    }\r\n}\r\n//客户端/接口\r\n$orderObj = new Order();\r\n$taobaoObj = new TaoBao($orderObj);\r\n$tmallObj = new Tmall($orderObj);\r\n$orderCenterObj = new OrderCenter();\r\n$orderCenterObj-&gt;setOrder($taobaoObj);\r\n$orderCenterObj-&gt;setOrder($tmallObj);\r\n$orderCenterObj-&gt;queue();\r\n[/code]', 1398667590, 11, 10, 0),
(38, 8, '李轩Lane', '面向对象的洗礼：设计模式（二十四）之职责链模式', '职责链模式解决了请求需要经过大量的臃肿的逻辑判断，设计模式的职责链模式采用了层层上报的方式，请求发送给响应方，响应方1若不能处理，则发送给响应2，响应2若不能处理则发送给响应3...直到处理为止。职责链模式的关键是，当客户提交一个请求时，请求是沿着一个链条进行传递，直到有一个对象可以负责这个请求为止。', '职责链模式_设计模式_设计模式之职责链模式', '职责链模式解决了请求需要经过大量的臃肿的逻辑判断，设计模式的职责链模式采用了层层上报的方式，请求发送给响应方，响应方1若不能处理，则发送给响应2，响应2若不能处理则发送给响应3，直到处理为止。', '职责链模式,设计模式,设计模式之职责链模式', 'PHP|设计模式|职责链模式', 79, '职责链模式解决了请求需要经过大量的臃肿的逻辑判断，设计模式的职责链模式采用了层层上报的方式，请求发送给响应方，响应方1若不能处理，则发送给响应2，响应2若不能处理则发送给响应3...直到处理为止。职责链模式的关键是，当客户提交一个请求时，请求是沿着一个链条进行传递，直到有一个对象可以负责这个请求为止。\r\n    职责链模式：使多个对象都有机会处理请求，从而避免了请求者和响应者的耦合关系，将响应者连成一个链条，层层传递，沿着这个链条传递请求，直到可以有一个对象处理为止。\r\n    职责链的好处：请求者和响应者都没有对方的明确信息，链中的对象也不知道链的结构，结果是职责模式中的职责链可以简化对象的相互连接，降低耦合，他们只需要保存一个继承者，而不需要保存所有的继承者。在增加和修改一个请求的结构时，更加灵活。\r\n    场景：请假，组长只能批1天的请假，技术总监可以批3天的请假，3天以上需要老板亲自批示。以PHP为代码环境来描述职责链模式。\r\n    \r\n[code]\r\n&lt;?php\r\nabstract class Manager{\r\n    protected $position;\r\n    protected $lead;\r\n    public function getPosition(){\r\n        return $this-&gt;position;\r\n    }\r\n    public function setPosition($position){\r\n        $this-&gt;position = $position;\r\n    }\r\n    public function setLead($leadObj){\r\n        $this-&gt;lead = $leadObj;\r\n    }\r\n}\r\nclass GroupLeader extends Manager{\r\n    public function __construct($position){\r\n        $this-&gt;position = $position;\r\n    }\r\n    public function response($day){\r\n        if($day == 1){\r\n            echo $this-&gt;position . ''批准&lt;br&gt;'';\r\n        }else{\r\n            echo $this-&gt;position . ''无权处理，请示上级&lt;br&gt;'';\r\n            $this-&gt;lead-&gt;response($day);\r\n        }\r\n    }\r\n}\r\nclass Director extends Manager{\r\n    public function __construct($position){\r\n        $this-&gt;position = $position;\r\n    }\r\n    public function response($day){\r\n        if($day &gt; 1 &amp;&amp; $day &lt;= 3){\r\n            echo $this-&gt;position . ''批准&lt;br&gt;'';\r\n        }else{\r\n            echo $this-&gt;position . ''无权处理，请示上级&lt;br&gt;'';\r\n            $this-&gt;lead-&gt;response($day);\r\n        }\r\n    }\r\n}\r\nclass CEO extends Manager{\r\n    public function __construct($position){\r\n        $this-&gt;position = $position;\r\n    }\r\n    public function response($day){\r\n        if($day &gt; 3){\r\n            echo $this-&gt;position . ''批准&lt;br&gt;'';\r\n        }else{\r\n            echo $this-&gt;position . ''无权处理，请示上级&lt;br&gt;'';\r\n            $this-&gt;lead-&gt;response($day);\r\n        }\r\n    }\r\n}\r\n//客户端/接口\r\n$groupLead = new GroupLeader(''组长'');\r\n$director  = new Director (''总监'');\r\n$ceo = new CEO(''首席执行官'');\r\n$groupLead-&gt;setLead($director);\r\n$director-&gt;setLead($ceo);\r\n$dayArr = array(1, 2, 3, 4, 5);\r\nforeach($dayArr as $day){\r\n    echo ''请假'' . $day . ''天结果&lt;br&gt;'';\r\n    $groupLead-&gt;response($day);\r\n    echo ''&lt;br&gt;&lt;br&gt;&lt;br&gt;'';\r\n}\r\n[/code]', 1398749898, 8, 14, 0),
(39, 8, '李轩Lane', '面向对象的洗礼：设计模式（二十五）之中介模式', '中介模式，是非常非常常见的一种设计模式。一般应用于一组对象以定义良好但是复杂的方式进行通信的场合。定制一个分布在多个类中的行为，而不像生成太多的子类。这是中介模式的应用场景。中介类的集中化控制即是中介模式的优点，又是中介模式的缺点。', '中介模式_设计模式_设计模式之中介模式', '中介模式，是非常非常常见的一种设计模式。一般应用于一组对象以定义良好但是复杂的方式进行通信的场合。定制一个分布在多个类中的行为，而不像生成太多的子类。这是中介模式的应用场景。', '中介模式,设计模式,设计模式之中介模式', 'PHP|设计模式|中介模式', 53, '中介模式，是非常非常常见的一种设计模式。一般应用于一组对象以定义良好但是复杂的方式进行通信的场合。定制一个分布在多个类中的行为，而不像生成太多的子类。这是中介模式的应用场景。\r\n    中介模式的优点：中介类的集中化控制。\r\n    中介模式的缺点：中介类的集中化控制。\r\n    中介模式的中介类，集中化控制了所有的对象，减少了请求者和响应者的耦合。把中介封装在一个对象中，注意力从关注对象本身变成了关注它们之间的交互，更加宏观。缺点也就显而易见，因为集中化的控制，使得中介类越发的庞大，不易维护。\r\n    场景：中介抽象类联合国，中介具体类安理会。成员抽象类为国家，成员具体类为美国和伊拉克。以PHP为代码环境来描述中介模式。\r\n    \r\n[code]\r\n&lt;?php\r\n&lt;?php\r\nabstract class UN{\r\n    public function sentMessage($message, $countryObj){}\r\n}\r\nabstract class Country{\r\n    protected $UNObj;\r\n    public function __construct($UNObj){\r\n        $this-&gt;UNObj = $UNObj;\r\n    }\r\n}\r\nclass US extends Country{\r\n    public function __construct($UNObj){\r\n        parent::__construct($UNObj);\r\n    }\r\n    public function sentMessage($message){\r\n        $this-&gt;UNObj-&gt;sentMessage($message, $this);\r\n    }\r\n    public function getMessage($message){\r\n        echo ''美国收到某国消息：'' . $message . ''&lt;br&gt;'';\r\n    }\r\n}\r\nclass Iraq extends Country{\r\n    public function __construct($UNObj){\r\n        parent::__construct($UNObj);\r\n    }\r\n    public function sentMessage($message){\r\n        $this-&gt;UNObj-&gt;sentMessage($message, $this);\r\n    }\r\n    public function getMessage($message){\r\n        echo ''伊拉克收到某国消息：'' . $message . ''&lt;br&gt;'';\r\n    }\r\n}\r\nclass UNSC extends UN{\r\n    private $usObj;\r\n    private $iraqObj;\r\n    public function setUsObj($obj){\r\n        $this-&gt;usObj = $obj;\r\n    }\r\n    public function setIraqObj($obj){\r\n        $this-&gt;iraqObj = $obj;\r\n    }\r\n    public function sentMessage($message, $sentObj){\r\n        if($this-&gt;usObj == $sentObj){\r\n            $this-&gt;iraqObj-&gt;getMessage($message);\r\n        }else{\r\n            $this-&gt;usObj-&gt;getMessage($message);\r\n        }\r\n    }\r\n}\r\n//客户端/接口\r\n$unsc = new UNSC();\r\n$us = new US($unsc);\r\n$iraq = new Iraq($unsc);\r\n$unsc -&gt;setUsObj($us);\r\n$unsc-&gt;setIraqObj($iraq);\r\n$us-&gt;sentMessage(''你们不可以研发核武器！'');\r\n$iraq-&gt;sentMessage(''我们没有和武器！'');\r\n[/code]', 1398845807, 8, 7, 0),
(40, 8, '李轩Lane', '面向对象的洗礼：设计模式（二十六）之享元模式', '享元模式解决了大量几乎相似的对象的这种情况。设计模式中的享元模式使程序运行时更加节省服务器资源。享元模式是一种非常好的设计模式。如果一个应用程序使用了大量的对象，而大量的这些对象对服务器资源造成了很大的开销和压力时，就应该考虑使用享元模式。', '享元模式_设计模式_设计模式之享元模式', '享元模式解决了大量几乎相似的对象的这种情况。设计模式中的享元模式使程序运行时更加节省服务器资源。享元模式是一种非常好的设计模式。', '享元模式,设计模式,设计模式之享元模式', 'PHP|设计模式|享元模式', 59, '享元模式解决了大量几乎相似的对象的这种情况。设计模式中的享元模式使程序运行时更加节省服务器资源。享元模式是一种非常好的设计模式。如果一个应用程序使用了大量的对象，而大量的这些对象对服务器资源造成了很大的开销和压力时，就应该考虑使用享元模式。\r\n    享元模式：运用共享技术有效的支持大量的细粒度对象。\r\n    比如：围棋只有黑白两种棋子，用一个对象生成黑棋子，一个对象生成白棋子，是要一份代码共享给所有的黑棋子共同使用呢，还是每个黑棋子独立一个对象。这就是享元模式，共享对象以达到节省开销的目的。\r\n    场景：阿里云旗下的万网提供快速建站的服务，它是给每个用户独立生成一个网站所有的源代码，还是说同类型的网站共享一份代码？答案是后者（示例仅为说明享元模式，并不代表万网的真实实现方式）。以PHP为代码环境，模拟设计模式之享元模式的代码实现。\r\n[code]\r\n&lt;?php\r\nclass User{\r\n    private $name;\r\n    public function __construct($name){\r\n        $this-&gt;setName($name);\r\n    }\r\n    public function setName($name){\r\n        $this-&gt;name = $name;\r\n    }\r\n    public function getName(){\r\n        return $this-&gt;name;\r\n    }\r\n}\r\nabstract class Website{\r\n    private $name;\r\n    public function __construct($name){\r\n        $this-&gt;setName($name);\r\n    }\r\n    public function setName($name){\r\n        $this-&gt;name = $name;\r\n    }\r\n    public function getName(){\r\n        return $this-&gt;name;\r\n    }\r\n}\r\nclass ConcreteWebsite extends Website{\r\n    public function __construct($name){\r\n        parent::__construct($name);\r\n    }\r\n    public function useWebsite($userObj){\r\n        echo ''网站名称：'' . $this-&gt;getName() . ''。 所属用户'' . $userObj-&gt;getName() . ''&lt;br&gt;'';\r\n    }\r\n}\r\nclass WebsiteFactory{\r\n    private $userWebsiteList = array();\r\n    public function getWebsite($key, $name){\r\n        if(!isset($this-&gt;userWebsiteList[$key])){\r\n            $this-&gt;userWebsiteList[$key] = new ConcreteWebsite($name);\r\n        }\r\n        return $this-&gt;userWebsiteList[$key];\r\n    }\r\n}\r\n//客户端/接口\r\n//网站工厂\r\n$websiteFactory = new WebsiteFactory();\r\n\r\n//采用万网提供的第一套模板并起名\r\n$website = $websiteFactory-&gt;getWebsite(''1'', ''LaneBlog'');\r\n$website-&gt;useWebsite(new User(''小轩''));\r\n\r\n//采用万网提供的第一套模板并起名\r\n$website = $websiteFactory-&gt;getWebsite(''1'', ''Lane博客'');\r\n$website-&gt;useWebsite(new User(''小明''));\r\n\r\n//采用万网提供的第一套模板并起名\r\n$website = $websiteFactory-&gt;getWebsite(''1'', ''LixuanBlog'');\r\n$website-&gt;useWebsite(new User(''小红''));\r\n\r\n//采用万网提供的第二套模板并起名\r\n$website = $websiteFactory-&gt;getWebsite(''2'', ''论坛'');\r\n$website-&gt;useWebsite(new User(''小白''));\r\n[/code]\r\n    根据结果可以看到，多个用户，前三个用户使用的是同一套系统。节省开销。至于名称，从库里读出来即可。这里完全不需要。', 1399008324, 16, 17, 0),
(41, 8, '李轩Lane', '面向对象的洗礼：设计模式（二十七）之解释器模式', '解释器模式，作为PHPer应该非常非常非常熟悉的一种，尽管不知道它叫做解释器模式，但是肯定使用过它。在解释器模式的最佳应用，就是大量优秀的模板引擎。解释器模式解决了一种特定的类型的问题发生的频率足够高，那么就可能值得将该问题的各个势力表述为一个简单的语言中的句子。这就构建了一个解释器，解释器他哦各国解释这些句子来解决问题。', '解释器模式_设计模式_设计模式之解释器模式', '解释器模式，作为PHPer应该非常非常非常熟悉的一种，尽管不知道它叫做解释器模式，但是肯定使用过它。在解释器模式的最佳应用，就是大量优秀的模板引擎。', '解释器模式,设计模式,设计模式之解释器模式', 'PHP|设计模式|解释器模式', 112, '解释器模式，作为PHPer应该非常非常非常熟悉的一种，尽管不知道它叫做解释器模式，但是肯定使用过它。在解释器模式的最佳应用，就是大量优秀的模板引擎。解释器模式解决了一种特定的类型的问题发生的频率足够高，那么就可能值得将该问题的各个势力表述为一个简单的语言中的句子。这就构建了一个解释器，解释器他哦各国解释这些句子来解决问题。\r\n    解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\r\n    比如：模板引擎smart；比如论坛的UBB代码，就是用[url=http://www.lanecn.com]LaneBlog[/url]来表示&lt;a href=&quot;http://www.lanecn.com/&gt;LaneBlog&lt;/a&gt;；还比如正则表达式等\r\n    场景：a表示你，b表示好，c表示世界。1表示我说，2表示你说。以PHP为代码环境，模拟设计模式之解释器模式的代码实现。\r\n[code]\r\n&lt;?php\r\nclass Content{\r\n    private $content = '''';\r\n    public function get(){\r\n        return $this-&gt;content;\r\n    }\r\n    public function set($content){\r\n        $this-&gt;content = $content;\r\n    }\r\n}\r\nclass Expression{\r\n    public function interpret($contentObj){\r\n        $content = $contentObj-&gt;get();\r\n        if(!empty($content)){\r\n            $lenth = strlen($content);\r\n            for($i=0; $i&lt;$lenth; $i++){\r\n                if(is_numeric($content[$i])){\r\n                    Number::excute($content[$i]);\r\n                }else if(is_string($content[$i])){\r\n                    String::excute($content[$i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nclass Number{\r\n    public static function excute($value){\r\n        $data = '''';\r\n        switch($value){\r\n            case 1:\r\n                $data = ''我说：'';\r\n                break;\r\n            case 2:\r\n                $data = ''你说：'';\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        echo $data;\r\n    }\r\n}\r\n//a表示你，b表示好，c表示世界。1表示我说，2表示你说\r\nclass String{\r\n    public static function excute($value){\r\n        $data = '''';\r\n        switch($value){\r\n            case ''a'':\r\n                $data = ''你'';\r\n                break;\r\n            case ''b'':\r\n                $data = ''好'';\r\n                break;\r\n            case ''c'':\r\n                $data = ''世界'';\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        echo $data;\r\n    }\r\n}\r\n//客户端/接口\r\n$contentObj = new Content();\r\n$str = ''1abc'';\r\n$contentObj-&gt;set($str);\r\necho ''解密'' . $str . ''：&lt;br&gt;'';\r\n$expression = new Expression();\r\n$expression-&gt;interpret($contentObj);\r\necho ''&lt;br&gt;'';\r\n$str = ''2abc'';\r\n$contentObj-&gt;set($str);\r\necho ''解密'' . $str . ''：&lt;br&gt;'';\r\n$expression = new Expression();\r\n$expression-&gt;interpret($contentObj);\r\n[/code]', 1399089833, 14, 11, 0),
(42, 8, '李轩Lane', '面向对象的洗礼：设计模式（二十八）之访问者模式', '访问者模式，是设计模式中最难的一种模式。访问者模式适用于数据结构相对稳定的系统。访问者模式对数据结构和作用于结构上的操作之间进行了一次解耦合。访问者模式的目的是把处理从数据结构分离出来。访问者模式的适用场景：所开发的系统具有比较问题的数据结构，又有抑郁变化的算法。', '访问者模式_设计模式_设计模式之访问者模式', '访问者模式，是设计模式中最难的一种模式。访问者模式适用于数据结构相对稳定的系统。访问者模式对数据结构和作用于结构上的操作之间进行了一次解耦合。', '访问者模式,设计模式,设计模式之访问者模式', 'PHP|设计模式|访问者模式', 64, '访问者模式，是设计模式中最难的一种模式。访问者模式适用于数据结构相对稳定的系统。访问者模式对数据结构和作用于结构上的操作之间进行了一次解耦合。访问者模式的目的是把处理从数据结构分离出来。\r\n    访问者模式的适用场景：所开发的系统具有比较问题的数据结构，又有抑郁变化的算法。因为访问者模式使得算法操作的增加和扩展变得容易。优点是增加新的操作更加容易，因为增加新操作就是意味着增加新的访问者，访问者模式将有关的行为集中到一个对象中。缺点显而易见了，就是改变数据结构变得下个对困难。\r\n    访问者模式：表示一个作用于某对象的结构中的各个元素的操作。它使你可以在不改变各元素的前提下定义作用于这些元素的新操作。\r\n    场景：人类分为男女，对于人类这个系统，分类是非常固定的，一个元素是男，一个元素是女（人妖滚粗）。男女对同一件事情往往有不同的观点。以PHP为代码环境，模拟设计模式之访问者模式的代码实现。（暂时没有想到好的例子，就从《大话设计模式》中访问者模式摘了一段）\r\n[code]\r\n&lt;?php\r\nclass Action{\r\n    public function getManView(Man $manObj){}\r\n    public function getWomanView(Woman $manObj){}\r\n}\r\nclass Person{\r\n    public function accept(Action $actionObj){}\r\n}\r\nclass Success extends Action{\r\n    public function getManView(Man $manObj){\r\n        echo sprintf(''%s成功时，背后多半有一个伟大的女人&lt;br&gt;'', $manObj-&gt;getName());\r\n    }\r\n    public function getWomanView(Woman $womanObj){\r\n        echo sprintf(''%s成功时，背后多半有一个不成功的女人&lt;br&gt;'', $womanObj-&gt;getName());\r\n    }\r\n}\r\nclass Failing extends Action{\r\n    public function getManView(Man $manObj){\r\n        echo sprintf(''%s失败时，闷头喝酒，谁也不用劝&lt;br&gt;'', $manObj-&gt;getName());\r\n    }\r\n    public function getWomanView(Woman $womanObj){\r\n        echo sprintf(''%s失败时，眼泪汪汪，谁也劝不住&lt;br&gt;'', $womanObj-&gt;getName());\r\n    }\r\n}\r\nclass Love extends Action{\r\n    public function getManView(Man $manObj){\r\n        echo sprintf(''%s恋爱时，凡事不懂也要装懂&lt;br&gt;'', $manObj-&gt;getName());\r\n    }\r\n    public function getWomanView(Woman $womanObj){\r\n        echo sprintf(''%s恋爱时，凡事懂也要装不懂&lt;br&gt;'', $womanObj-&gt;getName());\r\n    }\r\n}\r\nclass Man extends Person{\r\n    private $name = ''男人'';\r\n    public function getName(){\r\n        return $this-&gt;name;\r\n    }\r\n    public function accept(Action $actionObj){\r\n        $actionObj-&gt;getManView($this);\r\n    }\r\n}\r\nclass Woman extends Person{\r\n    private $name = ''女人'';\r\n    public function getName(){\r\n        return $this-&gt;name;\r\n    }\r\n    public function accept(Action $actionObj){\r\n        $actionObj-&gt;getWomanView($this);\r\n    }\r\n}\r\nclass ObjectStructure{\r\n    private $elementList;\r\n    public function add(Person $elementObj){\r\n        $this-&gt;elementList[] = $elementObj;\r\n    }\r\n    public function display(Action $visitorObj){\r\n        foreach($this-&gt;elementList as $element){\r\n            $element-&gt;accept($visitorObj);\r\n        }\r\n    }\r\n}\r\n//客户端/接口\r\n$o = new ObjectStructure();\r\n$o-&gt;add(new Man());\r\n$o-&gt;add(new Woman());\r\n\r\n$successObj = new Success();\r\n$o-&gt;display($successObj);\r\n\r\n$failingObj = new Failing();\r\n$o-&gt;display($failingObj);\r\n\r\n$loveObj = new Love();\r\n$o-&gt;display($loveObj);\r\n[/code]\r\n    这里用到一个双分派技术。客户端将状态（成功、失败、恋爱）作为参数传递给男人，这是第一次分派。男人类调用作为参数的“具体状态中的方法-男人的观点”，同时将自身传递给状态的对象，这是第二次分派。双分派意味着得到执行的操作决定于请求的种类和两个接收者的类型。双分派的好处是，如果要增加结婚类，只需要增加如下：\r\n[code]\r\nclass Marry extends Action{\r\n    public function getManView(Man $manObj){\r\n        echo sprintf(''%s结婚时，有妻徒刑&lt;br&gt;'', $manObj-&gt;getName());\r\n    }\r\n    public function getWomanView(Woman $womanObj){\r\n        echo sprintf(''%s结婚时，婚姻保险&lt;br&gt;'', $womanObj-&gt;getName());\r\n    }\r\n}\r\n[/code]\r\n除此之外，客户端在需要的时候调用即可。不需要动其他的代码，增加新算法，只需要扩展一个新类。完美体现开放-封闭原则。', 1399214709, 12, 10, 0);
INSERT INTO `info_article` (`id`, `mid`, `author`, `title`, `description`, `seo_title`, `seo_description`, `seo_keywords`, `tag`, `clicks`, `content`, `ctime`, `good_num`, `bad_num`, `recommend_type`) VALUES
(43, 9, '李轩Lane', 'Python学习第一阶段：Python的电话本', 'Python学习第一阶段：Python的电话本。涉及了Python的基础内容，数据类型中的字典，类，存储器等。对电话本进行查询，增加，删除，修改的功能。', 'Python示例_用Python实现电话本逻辑。', 'Python学习第一阶段：Python的电话本。涉及了Python的基础内容，数据类型中的字典，类，存储器等。', 'Python示例,用Python实现电话本逻辑。', 'Python|Python基础|Python示例', 140, '本例是Python基础示例。涉及Python基础，包括语法、字典型数据结构、类、引入库、pickle实现的存储器、异常处理等。\r\n    示例是一个电话本。可以对电话本进行增加、删除、修改、获取列表和获取单人的。\r\n    Python中，Pickle和cPickle都可以完成存储器的任务，不过cPickle是C语言所写，据称性能高于Pickle1000倍\r\n    Python中的Pickle是把一个对象存入文件中。作为完全面向对象的语言，在声明/初始化一个变量的时候，比如字典，也就是关联数组，Python其实是在实例化一个字典对象。那么Pickle就可以把这个字典对象存入一个文件，读出来的时候不但这个字典是完整的数据，而且可以继续使用这个字典对象的方法。\r\n    Python是用缩进来时别语句块的。因为我是在VIM下写好复制出来的，所以在博客看到的可能缩进会有问题。\r\n[code]\r\n#引入pickle库。cPickle比Pickle快1000倍\r\nimport cPickle as pickle\r\n#import Pickle as pickle\r\n\r\n#电话本类\r\nclass Address:\r\n    #初始化\r\n    def __init__(self):\r\n        #把数据存到那个文件里\r\n	    self.filename = ''list.data''\r\n	    f = file(self.filename)\r\n        #如果文件是新建的或者是空内容的，则初始化为一个空的字典（关联数组）\r\n        try:\r\n            self.lists = pickle.load(f)\r\n        except:\r\n            print ''Address Book is empty.initializing.....''\r\n            self.lists = {}\r\n	    f.close()\r\n    #添加联系人\r\n    def add(self, name, age, mobile, mail):\r\n	    newUser = {''name'':name, ''age'':age, ''mobile'':mobile, ''mail'':mail}\r\n	    self.lists[name] = newUser\r\n    #删除联系人\r\n    def delete(self, name):\r\n        if name in self.lists:\r\n            del self.lists[name]\r\n            print ''delete '', name\r\n        else:\r\n            print ''No exists '', name\r\n    #获取列表\r\n    def getList(self):\r\n        print ''Address Book List:''\r\n        print self.lists\r\n    #获取指定姓名的联系人\r\n    def getOne(self, name):\r\n        if name in self.lists:\r\n            print self.lists[name]\r\n        else:\r\n            print ''Not Exists:'', name\r\n    #修改联系人\r\n    def edit(self, name, key, value):\r\n	    self.lists[name][key] = value\r\n    #类运行结束，执行特殊方法__del__，也就是析构函数\r\n    def __del__(self):\r\n        f = file(self.filename, ''w'')\r\n        pickle.dump(self.lists, f)\r\n        f.close()\r\n\r\n#初始化电话本类\r\nobj = Address()\r\n#添加一个联系人\r\nobj.add(''lane'', 23, 18500000000, ''lixuan868686@163.com'')\r\n#获取所有联系人的列表\r\nobj.getList()\r\n#获取lane这个人的联系方式\r\nobj.getOne(''lane'')\r\n#获取xiaoming这个人的联系方式\r\nobj.getOne(''xiaoming'')\r\n//修改lane这个人的年龄为24\r\nobj.edit(''lane'', ''age'', ''24'')\r\n[/code]', 1399544003, 28, 16, 0),
(44, 10, '李轩Lane', 'Redis数据结构详解，五种数据结构分分钟掌握', 'redis数据类型共有五种，介绍redis数据类型和redis数据命令。redis数据结构分为字符串类型、散列类型、列表类型、集合类型、有序集合类型。来看看如何使用redis的数据类型和redis数据命令吧。', 'redis数据类型_redis数据命令_redis数据结构', 'redis数据类型共有五种，介绍redis数据类型和redis数据命令。redis数据结构分为字符串类型、散列类型、列表类型、集合类型、有序集合类型。来看看如何使用redis的数据类型和redis数据命令吧。', 'redis数据类型,redis数据命令,redis数据结构', 'redis|redis数据类型|redis数据命令', 383, 'redis数据类型分为：字符串类型、散列类型、列表类型、集合类型、有序集合类型。\r\n    redis这么火，它运行有多块？一台普通的笔记本电脑，可以在1秒钟内完成十万次的读写操作。\r\n    原子操作：最小的操作单位，不能继续拆分。即最小的执行单位，不会被其他命令插入。高并发下不存在竞态条件。\r\n    KEY的命名：一个良好的建议是article:1:title来存储ID为1的文章的标题。\r\n    一、前言。\r\n        1、获取key的列表：KEYS pattern 通配符有？*[]和转义\\\r\n        2、key是否存在： EXISTS key 存在返回1，不存在返回0.\r\n        3、建立key和删除key：SET key 和 DEL key\r\n        4、根据key获取该键所存储的redis数据类型：TYPE key。返回是string、list、hash、set、zset。下面会对这5种返回的redis数据类型逐一讲解。\r\n        5、rename oldkey newkey：对key重命名，如果newkey存在则覆盖。\r\n        6、renamenx oldkey newkey：对key重命名，如果newkey存在则不覆盖。\r\n        7、randomkey：随即返回一个key\r\n        8、move key db-index：将key移动到指定的数据库中，如果key不存在或者已经在该数据库中，则返回0。成功则返回1.\r\n\r\n\r\n    二、Redis数据类型 Redis数据命令\r\n      1、Redis数据类型一字符串类型：\r\n            这个很好理解，一个key存储一个字符串。如果你要存数据呢？转换成Json或者其他的字符串序列化。\r\n\r\n      2、Redis数据命令一字符串类型：\r\n            1）赋值：SET key value。如set hello world\r\n            2）取值：GET key。如get hello。返回是world\r\n            3）自增：INCR key。就是Mysql的AUTO_INCREMENT。每次执行INCR key时，该key的值都会+1.若key不存在，则先建立一个0，然后+1，返回1。如果值不是整数则报错。该操作是原子操作。\r\n            4）自减：DECR key。将指定key的值减少1.如DECR num，就是num-1\r\n            5）自增N：INCRBY key increment用来给指定key的值加increment。如INCRBY num 5就是num+5\r\n            6）自减N：DECRBY key increment用来给指定key的值减increment。如DECRBY num 5就是num-5\r\n            7）增加浮点数：INCRBYFLOAT key increment。\r\n            8）向尾部追加：APPEND key value。如set test:key 123     append test:key 456      get test:key就是123456\r\n            9）获取长度：STRLEN key。\r\n            10）同时给多个key 赋值：MSET title 这是标题 description 这是描述 content 这是内容。\r\n            11）同时获取多个key的值：MGET title description content\r\n            12）位操作之获取：GETBIT key offset。如字符a在redis中的存储为01100001（ASCII为98），那么GETBIT key 2就是1，GET key 0就是0。\r\n            13）位操作之设置：SETBIT key offset value。如字符a在redis中的存储为01100001（ASCII为98），那么SETBIT key 6 0，SETBIT key 5 1那么get key得到的是b。因为取出的二进制为01100010。\r\n            14）位操作之统计：BITCOUNT key [start] [end]：BITCOUNT key用来获取key的值中二进制是1的个数。而BITCOUNT key start end则是用来统计key的值中在第start和end之间的子字符串的二进制是1的个数（好绕啊）。\r\n            15）位操作之位运算：BITOP operation resultKey key1 key2。operation是位运算的操作，有AND，OR，XOR，NOT。resultKey是把运算结构存储在这个key中，key1和key2是参与运算的key，参与运算的key可以指定多个。\r\n\r\n      3、Redis数据类型二散列类型：\r\n\r\n        Redis是以字典（关联数组）的形式存储的，一个key对应一个value。在字符串类型中，value只能是一个字符串。那么在散列类型，也叫哈希类型中，value对应的也是一个字典（关联数组）。那么就可以理解，Redis的哈希类型/散列类型中，key对应的value是一个二维数组。但是字段的值只可以是字符串。也就是说只能是二维数组，不能有更多的维度。\r\n\r\n      4、Redis数据命令二散列类型：\r\n            1）赋值：HSET key field value。如hset user name lane。hset user age 23\r\n            2）取值：HGET key field。如hget user name，得到的是lane。\r\n            3）同一个key多个字段赋值：HMSET key field1 value1 field2 value2...\r\n            4）同一个KEY多个字段取值：HMGET key field1 fields2...\r\n            5）获取KEY的所有字段和所有值：HGETALL key。如HGETALL user得到的是name lane age 23。每个返回都是独立的一行。\r\n            6）字段是否存在：HEXISTS key field。存在返回1，不存在返回0\r\n            7）当字段不存在时赋值：HSETNX key field value。如果key下面的字段field不存在，则建立field字段，且值为value。如果field字段存在，则不执行任何操作。它的效果等于HEXISTS + HSET。但是这个命令的优点是原子操作。再高的并发也不会怕怕。\r\n            8）自增N：HINCREBY key field increment。同字符串的自增类型，不再阐述。\r\n            9）删除字段：DEL key field1 field2...删除指定KEY的一个或多个字段。\r\n            10）只获取字段名：HKEYS key。与HGETALL类似，但是只获取字段名，不获取字段值。\r\n            11）只获取字段值：HVALS key。与HGETALL类似，但是只获取字段值，不获取字段名。\r\n            12）获取字段数量：HLEN key。\r\n\r\n      5、Redis数据类型三列表类型：\r\n            列表类型存储了一个有序的字符串列表。常用的操作是向两端插入新的元素。时间复杂度为O（1）。结构为一个链表。记录头和尾的地址。看到这里，Redis数据类型的列表类型一个重大的作用呼之欲出，那就是队列。新来的请求插入到尾部，新处理过的从头部删除。另外，比如微博的新鲜事。比如日志。列表类型就是一个下标从0开始的数组。由于是链表存储，那么越靠近头和尾的元素操作越快，越靠近中间则越慢。\r\n\r\n      6、Redis数据命令三列表类型：\r\n            1）向头部插入：LPUSH key value1 value2...。返回增加后的列表长度。\r\n            2）向尾部插入：RPUSH key value1 value2...。返回增加后的列表长度。\r\n            3）从头部弹出：LPOP key。返回被弹出的元素值。该操作先删除key列表的第一个元素，再将它返回。\r\n            4）从尾部弹出：RPOP key。返回被弹出的元素值。\r\n            5）列表元素个数：LLEN key。key不存在返回0。\r\n            6）获取列表的子列表：LRANGE start end。返回第start个到第end个元素的列表。包含start和end。支持负数索引。-1表示最后一个元素，-2表示倒数第二个元素。\r\n            7）删除列表中指定值：LREM key count value。删除key这个列表中，所有值为value的元素，只删除count。如果有count+1个，那么就保留最后一个。count不存在或者为0，则删除所有的。如果count大于0，则删除从头到尾的count个，如果count小于0，则删除从尾到头的count个。\r\n            8）获取指定索引值：LINDEX key index。如LINDEX key 0就是列表的第一个元素。index可以是负数。\r\n            9）设置索引和值：LSET key index value。这个操作只是修改指定key且指定index的值。如果index不存在，则报错。\r\n            10）保留片段，删除其它：LTRIM key start end。保留start到end之间的所有元素，含start和end。其他全部删除。\r\n            11）向列表插入元素：LINSERT key BEFORE/AFTER value1 value2。从列表头开始遍历，发现值为value1时停止，将value2插入，根据BEFORE或者AFTER插入到value1的前面还是后面。\r\n            12）把一个列表的一个元素转到另一个列表：RPOPLPUSH list1 list2。将列表list1的右边元素删除，并把该与元素插入到列表list2的左边。原子操作。\r\n\r\n      7、Redis数据类型四集合类型：\r\n            集合类型是为了方便对多个集合进行操作和运算。集合中每个元素不同且没有顺序的概念，每个元素都是且只能是一个字符串。常用操作是对集合插入、删除、判断等操作。时间复杂度尾O(1)。可以进行交集、并集、差集运算。例如文章1的有3个标签，是一个Redis数据类型集合类型存储。文章2有3个标签，有一个Redis数据类型集合类型存储。文章是1是mysql，文章2是讲redis。那么交集是不是就交出了一个数据库？（假设数据库这个tag在两篇文字都有）。集合类型在redis中的存储是一个值为空的散列表。\r\n\r\n      8、Redis数据命令四集合类型：\r\n            1）增加：SADD key value。\r\n            2）删除：SREM key value。\r\n            3）获取指定集合的所有元素：SMEMBERS key。\r\n            4）判断某个元素是否存在：SISMEMBER key value。\r\n            5）差集运算：SDIFF key1 key2...。对多个集合进行差集运算。\r\n            6）交集运算：SINNER key1 key2...。对多个集合进行交集运算。\r\n            7）并集运算：SUNION key1 key2...。对多个集合进行并集运算。\r\n            8）获取集合中元素个数：SCARD key。返回集合中元素的总个数。\r\n            9）对差集、交集、并集运算的结果存放在一个指定的key中：SDIFFSTORE storekey key1 key2。对key1和key2求差集，结果存放在key为storekey的集合中。SINNERSTORE和SUNIONSTORE类似。\r\n            10）获取集合中的随即元素：SRANDMEMBER key [count]。参数count可选，如果count不存在，则随即一个。count大于0，则是不重复的count个元素。count小于0，则是一共|count|个元素，可以重复。\r\n            11）随即弹出一个元素：SPOP key。随即从集合中弹出一个元素并删除，将该元素的值返回。\r\n\r\n      9、Redis数据类型五有序集合类型：\r\n            集合类型是无序的，每个元素是唯一的。那么有序集合就是有序的，每个元素是唯一的。有序集合类型和集合类型的差别是，有序集合为每个元素配备了一个属性：分数。有序集合就是根据分数来排序的。有序集合是使用散列表和跳跃表实现的。所以和列表相比，操作中间元素的速度也很快。时间复杂度尾O(log(N))。Redis数据类型中的有序集合类型比Redis数据类型中的列表类型更加耗费资源。\r\n\r\n      10、Redis数据命令五有序集合类型：\r\n            1）增加：ZADD key sorce1 value1 sorce2 value2...。\r\n            2）获取分数：ZSCORE key value。获取key的有序集合中值为value的元素的分数。\r\n            3）获取排名在某个范围内的元素列表：ZRANFGE key start stop [WITHSCORE]。获取排名在start和end之间的元素列表，包含start和end2个元素。每个元素一行。如果有WITHSCORE参数，则一行元素值，一行分数。时间复杂度为O(LOGn+m)。如果分数相同，则0&lt;0&lt;A&lt;Z&lt;a&lt;z。\r\n            4）获取指定分数范围的元素：ZRANGEBYSCORE key min max [WITHSCORE] [LIMIT offset count]。获取分数在min和max之间的元素列表。含两头。每个元素一行。如果有WITHSCORE参数，则一行元素值，一行分数。如果min大于max则顺序反转。\r\n            5）为某个元素增加分数：ZINCRBY key increment value。指定的有序集合的值为value的元素的分数+increment。返回值后更改后的分数。\r\n            6）获取集合中元素的数量：ZCARD key。\r\n            7）获取指定分数范围内的元素个数：ZCOUNT key min max。\r\n            8）删除一个或多个元素：ZREM key value1 value2...\r\n            9）根据排名范围删除元素：ZREMRANGEBYRANK key start end。删除排名在start和end中的元素。\r\n            10）按照分数范围删除元素：ZREMRANGEBYSCORE key min max。\r\n            11）获得元素排名（正序）：ZRANK key value。获取value在该集合中的从小到大的排名。\r\n            12）获得元素排名（倒序）：ZREVRANK key value。获取value在该集合中从大到小的排名。\r\n            13）有序集合的交集：ZINTERSTORE storekey key1 key2...[WEIGHTS weight [weight..]] [AGGREGATE SUM|MIN|MAX]。用来计算多个集合的交集，结果存储在storekey中。返回值是storekey的元素个数。AGGREGATE为SUM则storekey集合的每个元素的分数是参与计算的集合分数和。MIN是参与计算的分数最小值。MAX是参与计算分数最大值。WEIGHTS 设置每个集合的权重，如WEIGHTS 1 0.1。那么集合A的每个元素分数*1，集合B的每个元素分数*0.1\r\n            14）有序集合的并集：ZUNIONSTORE storekey key1 kye2...[WEIGHTS weight [weight..]] [AGGREGATE SUM|MIN|MAX]', 1399792603, 20, 21, 2),
(45, 10, '李轩Lane', 'Redis事务，Redis事务处理', 'Redis事务以及事务的处理方式，Redis的事务教程将在本篇讲解。事务功能在数据完整性和数据一致性发挥着不可或缺的巨大的作用。Redis数据库为我们提供了不那么完美的Redis事务功能和Redis事务操作。为什么提供了事务缺说不那么完美呢？', 'Redis事务_Redis事务教程_Redis事务处理', 'Redis事务的实现，Redis事务处理方式等Redis的事务教程将在本篇讲解。事务功能在数据完整性和数据一致性发挥着不可或缺的巨大的作用。Redis数据库为我们提供了不那么完美的Redis事务功能和Redis事务操作。', 'Redis事务,Redis事务教程,Redis事务处理', 'redis|事务|redis事务', 71, 'Redis事务以及事务的处理方式，Redis的事务教程将在本篇讲解。事务功能在数据完整性和数据一致性发挥着不可或缺的巨大的作用。Redis数据库为我们提供了不那么完美的Redis事务功能和Redis事务操作。为什么提供了事务缺说不那么完美呢？本篇是Redis事务教程之入门篇。\r\n    事务也是Redis的最小执行单位，是原子的，不怕高并发下的竞态条件。一个事务的多条命令语句要么都执行，要么都不执行。事务的应用也非常广泛。Redis事务的原理是先将一个事务命令发送给Redis，然后再让Redis一次执行这些命令。 如：\r\n[code]\r\nredis&gt;MULTI\r\nOK\r\nredis&gt;SADD user:10002:friendId 10001\r\nQUEUE\r\nredis&gt;SADD user:10001:friendId 10002\r\nQUEUE\r\nredis&gt;EXEC\r\n1)integer 1\r\n2)integer 1\r\n[/code]\r\n    MULT告诉Redis开始一个事务，EXEC告诉Redis执行一个事务。中间两条SADD是属于同一个事务的语句。返回结果是第一条结果1，第二条语句结果1。如果，两条语句语法错误呢？\r\n[code]\r\nredis&gt;MULTI\r\nOK\r\nredis&gt;SADD user:10002:friendId 10001\r\nQUEUE\r\nredis&gt;SADDDDDD user:10001:friendId 10002\r\nERR unknown command ‘SADDDDD’\r\nredis&gt;EXEC\r\nERROR..............\r\n[/code]\r\n    如果语法错误，在录入Redis事务的过程中，Redis就会发现，并提示错误，在EXEC之后，仍然会返回错误提示，两条Redis事务的语句都不会被执行。可是，如果语法没有错误，可是在执行的时候却发生了错误呢？比如用SADD（集合类型的操作）去操作一个字符串数据类型的key呢？\r\n[code]\r\nredis&gt;MULTI\r\nOK\r\nredis&gt;SET num 1\r\nQUEUE\r\nredis&gt;SADD num 2\r\nQUEUE\r\nredis&gt;EXEC\r\n1)integer 1\r\n2)ERR ....................\r\n[/code]\r\n    可以看到，如果用集合类型的操作命令去操作字符串类型的key的话，第一条语句是正常执行并返回1.第二条语句却报错了。如果GET num可以的得到结果是1。也就是说即使有一条语句错误，但是第一条是执行成功了。这就是Redis提供了Redis事务机制，但是在操作中，不完美地方，Redis事务操作不提供所谓的回滚。\r\n    不过Redis却提供了一个新的办法，叫做WATCH命令。生病了，坐不住了。关于WATCH的内容下篇写。。', 1399897715, 14, 13, 0),
(46, 10, '李轩Lane', 'Redis WATCH命令详解，监听指定的键值变化', 'Redis WATCH是用来补充那不完美的事务功能，Redis WATCH命令监听指定KEY的变化。本篇是Redis WATCH详解部分。对Redis WATCH命令如何使用，有什么作用来进行讲解。', 'Redis WATCH_Redis WATCH命令_Redis WATCH详解', 'Redis WATCH是用来补充那不完美的事务功能，Redis WATCH命令监听指定KEY的变化。本篇是Redis WATCH详解部分。对Redis WATCH命令如何使用，有什么作用来进行讲解。', 'Redis WATCH,Redis WATCH命令,Redis WATCH详解', 'redis|redis watch', 85, 'Redis WATCH是用来补充那不完美的事务功能，Redis WATCH命令监听指定KEY的变化。本篇是Redis WATCH详解部分。对Redis WATCH命令如何使用，有什么作用来进行讲解。WATCH是Redis事务系统中的一个成员命令。它有一个参数，是key。Redis WATCH命令的作用是监听在参数位置指定的key（key可以是五种类型中任意一种），如果这个key被修改或者被删除了，那么WATCH命令的监听作用就停止了，同时WATCH命令后面的第一个事务将不会被执行，直接跳过。\r\n[code]\r\nredis&gt;SET num 1\r\nOK\r\nredis&gt;WATCH num\r\nOK\r\nredis&gt;SET num 2\r\nOK\r\nredis&gt;MULTI\r\nOK\r\nredis&gt;SET num 3\r\nQUEUE\r\nredis&gt;EXEC\r\n(nil)\r\nredis&gt;GET num\r\n&quot;2&quot;\r\n[/code]\r\n    上例可以看出，Redis的WATCH命令的作用。值的注意的时，在WATCH监听的key被修改或删除后，WATCH后的第一个事务不会被执行，但是第二个、第三个、第N个都是会正常执行的。', 1399987434, 12, 13, 0),
(47, 10, '李轩Lane', 'Redis生存时间，对Redis的键设置生存时间', 'Redis生存时间的概念，是和编程语言一样，拥有Redis生命周期，对键设定永久生效或指定生效时间。Redis过期删除键和值。Redis的生存时间和Redis的生命周期如何使用，本篇会详细讲解。', 'redis生存时间_redis生命周期_redis过期删除', 'Redis生存时间的概念，是和编程语言一样，拥有Redis生命周期，对键设定永久生效或指定生效时间。Redis过期删除键和值。Redis的生存时间和Redis的生命周期如何使用，本篇会详细讲解。', 'redis生存时间,redis生命周期,redis过期删除', 'redis|生存时间', 86, 'Redis对键提供生存时间，在不指定生存时间时，生存时间是永久。时间到期后Redis会自动删除这个键。可以用EXPIRE命令，时间单位时秒，如果一个键是被设为有限的生存时间，那么在SET key进行重新赋值的时候会被再次设为永久：\r\n[code]\r\nSET session:captcha sd2a\r\nEXPIRE session:captcha 600\r\n[/code]\r\n    取消生存时间，将键的生存时间设为永久，是PERSIST：\r\n[code]\r\nPERSIST session:captcha\r\n[/code]\r\n    查看一个键的生存时间用TTL命令，-1表示永久或者以及到期被删除。\r\n[code]\r\nTTL session:captcha\r\n[/code]\r\n    在Redis的INCR，LPUSH，HSET，ZREM等命令时不会改变生存时间的。\r\n    想要精确到毫米来控制时间，就需要PEXPIRE即可，使用PTTL查看剩余时间。\r\n    如果想要给定一个到期的时间而不是多少秒后到期呢？就需要EXPIREAT和PEXPIREAT。EXPIREAT的参数是到期时的时间戳（秒），PEXPIREAT的参数是到期时间是时间戳（毫秒）\r\n[code]\r\nSET session:captcha sd2a\r\nEXPIREAT session:captcha 1399902009\r\nPEXPIREAT session:captcha 1399902009000\r\n[/code]\r\n\r\n\r\n    应用场景一：访问频率限制：我们限定每个用户1分钟只能浏览10个页面。伪代码如下：\r\n[code]\r\n$isExists = EXISTS limit:user1:192.168.1.2\r\nif($isExists){\r\n    $num = INCR limit:user1:192.168.1.2\r\n    if($num &gt; 10){\r\n        print ''超过限制''\r\n        exit\r\n    }\r\n}else{\r\n    MULTI\r\n    INCR limit:user1:192.168.1.2\r\n    EXPIRE limit:user1:192.168.1.2 60\r\n    EXEC\r\n}\r\n[/code]\r\n    我们用了事务的原因是因为，加入在执行了INCR limit:user1:192.168.1.2之后，在执行EXPIRE limit:user1:192.168.1.2 60之前，客户端被关闭了。那么这个键和值就会被持久化保存。且该ID终身只能访问10次了。这就太糟糕了。\r\n\r\n\r\n    应用场景二：实现缓存。计算一万名用户的排行榜，是很耗费资源的，那么我们把数据在第一次计算后存进一个key，然后对这个key设置生存时间。在1个小时后生存时间到期，key被删除，再次进行计算新排名并保存的一个临时key。我们用伪代码实现：\r\n[code]\r\n//战斗排行榜\r\n$rank = GET cache:rank:fight\r\nif not $rank\r\n    $rank = 计算排名()\r\n    MULTI\r\n    SET cache:rank:fight $rank\r\n    EXPIRE cache:rank:fight 3600\r\n    EXEC\r\n[/code]\r\n    Redis是内存存储的数据库，假如内存被缓存占满了，Redis会根据配置文件来删除一定的缓存。配置项是Redis的配置文件中的maxmemory参数，单位是字节。超过这个限制之后，会根据配置文件的maxmemory-policy参数来删除不需要的键。maxmemory-policy的可选规则是如下四种：\r\n    1、volatile-lru：使用LRU算法删除一个键（设置了生存时间的键）。\r\n    2、allkey-lru：使用LRU算法删除一个键。\r\n    3、volatile-random：随即删除一个键（设置了生存时间的键）。\r\n    4、allkey-random：随即删除一个键。\r\n    5、volatile-ttl：删除生存时间即将过期的一个键。是随即取出来N个键，然后删除N个键中即将过期的键，而不是遍历所有的键删除即将过期的。N是几？配置文件配的。\r\n    6、nevication：不删除，返回错误。', 1400070031, 13, 11, 0),
(48, 10, '李轩Lane', 'Redis SORT排序命令详解', 'Redis SORT提供排序功能，Redis SORT排序命令是最好用也是最复杂的redis命令之一。关系型数据库能完成的包括多表联合查询等能够都可以轻松完成。', 'Redis SORT_Redis SORT命令_Redis SORT排序', 'Redis SORT提供排序功能，Redis SORT排序命令是最好用也是最复杂的redis命令之一。关系型数据库能完成的包括多表联合查询等能够都可以轻松完成。', 'Redis SORT,Redis SORT命令,Redis SORT排序', 'redis|排序|redis SORT', 104, 'Redis SORT是由Redis提供的一个排序命令。集合中的标签是无序的，可以使用SORT排序。如：\r\n[code]\r\nredis&gt;SADD jihe 5\r\n(integer) 1\r\nredis&gt;SADD jihe 1\r\n(integer) 1\r\nredis&gt;SADD jihe 2\r\n(integer) 1\r\nredis&gt;SADD jihe 8\r\n(integer) 1\r\nredis&gt;SORT jihe\r\n1) &quot;1&quot;\r\n2) &quot;2&quot;\r\n3) &quot;5&quot;\r\n4) &quot;8&quot;\r\n[/code]\r\n    如果使用Redis SORT排序的不是数字，是字母，将他们按照字典的顺序排名，则需要使用\r\n[code]\r\nSORT jihe ALPHA\r\n[/code]\r\n    如果不加ALPHA参数，则会报错，提示：(error) ERR One or more scores can''t be converted into double。我们还可以使用关系型数据库的DESC进行倒序排序和LIMIT offset count来限定获取的条数\r\n[code]\r\nSORT jihe DESC LIMIT 0 2\r\n[/code]\r\n    还可以对Redis SORT命令添加BY参数。一条语句只能有一个BY参数。这时，SORT不会根据自身的值排序，比如（1，5，2，8和a，A，g，B），而是根据指定的另一个键中的字段来排序。如：\r\n[code]\r\nSORT tag:redis:article BY article:*-&gt;time DESC\r\n[/code]\r\n    解释：根据tag:redis:article中的值（tag是redis的文章ID），来组合成一个新的key就是article:(ag:redis:article中的一个值):time。获取到tag是redis的文章ID列表，然后根据他们的发布时间来排序。\r\n    Redis SORT命令还有个GET参数，GET参数类似在关系型数据库中的关联查询。比如查询tag是redis的文章ID列表，将列表根据发布时间倒序排序，然后获取每个文章的标题。GET可以有多个：\r\n[code]\r\nSORT tag:redis:article BY article:*-&gt;time DESC GET article:*-&gt;title GET article:*-&gt;time GET #\r\n[/code]\r\n    GET #的意思是，将文章ID返回回来，你可以写GET article:*-&gt;id，也可以写GET #。\r\n    Redis SORT命令还有个参数是STORE，是将排序后的内容存储到一个新的key中。新key的类型是列表类型，如果存在则会覆盖。这个时候可以用EXPIRE来设置缓存：\r\n[code]\r\nSORT tag:redis:article BY article:*-&gt;time DESC GET article:*-&gt;title GET article:*-&gt;time GET # STORE resultKey\r\n[/code]\r\n    Redis的SORT命令是Redis最复杂最强大的命令之一，时间复杂度是O(n+mLOGm)。n是待排序的列表长度，m是返回的元素个数。减少n和m会提高SORT的性能。', 1400160036, 10, 10, 0),
(49, 10, '李轩Lane', 'Redis队列如何实现？Redis栈逻辑如何实现', 'Redis队列如何实现？Redis栈原来是怎么样的？Redis的队列和栈机制是怎样的？本篇讲解Redis的队列技术。做为天生的队列好手，无论是先进先出的队列还是后进先出栈都是可以利用Redis来实现的。', 'Redis队列_redis栈_redis队列原理', 'Redis队列如何实现？Redis栈原来是怎么样的？Redis的队列和栈机制是怎样的？本篇讲解Redis的队列技术。做为天生的队列好手，无论是先进先出的队列还是后进先出栈都是可以利用Redis来实现的。', 'Redis队列,redis栈,redis队列原理', 'redis|队列|栈', 80, 'Redis是天生的队列好手。RPOP，LPUSH就可以看到。生产者是队列任务的提出方，消费者队列任务的执行方。生产者提出大量的任务，他们排队一个接一个的被消费者执行。执行一个就RPOP，提出一个新任务就LPUSH。如果要插队呢？就RPUSH。Redis队列的伪代码：\r\n[code]\r\n//无限循环\r\nloop\r\n    $task = RPOP queue\r\n    if($task)\r\n        execute($task)\r\n    else\r\n        sleep(1)\r\n[/code]\r\n    一个无限循环，从队列的最头部弹出一个任务，如果该任务存在则执行，如果不存在则睡眠，1秒后再次进入循环。这段代码实现了对队列任务的死循环来进行监听任务列表。这样并不好，每1秒扫描一次，如果一晚上都没有呢，那不是在白白浪费资源吗。这时候借助Redis 队列命令家族中的BRPOP。如果队列列表中有任务则弹出，如果没有任务就一直将连接阻塞，直到有新的任务加入才会放开。\r\n[code]\r\n//无限循环\r\nloop\r\n    $task = BRPOP queue 0\r\n    execute($task)\r\n[/code]\r\n    BRPOP第一个参数是键，第二个参数是时间，如果时间为0则没有新任务加入的时候永久阻塞。\r\n    Redis队列家族是可以进行优先级的。比如有三个列表任务列表，queue1，queue2，queue3。那么那个优先级高就拍在前面：\r\n[code]\r\n    BRPOP queue2 queue3 queue1 0\r\n[/code]\r\n    如果队列2中有任务则优先弹出任务2。', 1400424825, 13, 12, 0),
(50, 10, '李轩Lane', 'Redis广播（订阅/发布者模式）：在线实时聊天的基础', 'Redis的订阅发布者模式，是利用Redis构建在线实时聊天的理论年基础和实现原理基础。Redis订阅发布者模式可以实现广播功能，订阅一个频道，给一个频道的所有关注着发送广播内容。', 'Redis广播_Redis订阅发布_Redis在线聊天', 'Redis的订阅发布者模式，是利用Redis构建在线实时聊天的理论年基础和实现原理基础。Redis订阅发布者模式可以实现广播功能，订阅一个频道，给一个频道的所有关注着发送广播内容。', 'Redis广播,Redis订阅发布,Redis在线聊天', 'redis|聊天|广播', 80, 'Redis是实时广播推送的一把好手。Redis提供了发布-订阅者模式。发布消息是PUBLISH 频道名 内容的格式。如：\r\n[code]\r\nPUBLISH fm97 hello world\r\n[/code]\r\n    这样，所有订阅fm7频道的用户就可以收到hello world了。PUBLISH返回值是收到的订阅者个数。订阅命令是SUBSCRIBE。如：\r\n[code]\r\nSUBSCRIBE fm97\r\n[/code]\r\n    在输入Redis订阅命令之后，值可以输入SUBSCRIBE/UNSUBSCRIBE/PSUBSCRIBE/PUNSUBSCRIBE这四个命令，不然会报错。在SUBSCRIBE模式下，收到的消息第一行是subscribe。第二行是频道名称fm97，第三行是当前的订阅数量。也可能是收到的消息第一行是message。第二行是频道名称fm97，第三行是广播内容hello world。\r\n    退定则是UNSUBSCRIBE，如\r\n[code]\r\nUNSUBSCRIBE fm97\r\n[/code]\r\n    PSUBSCRIBE 通过通配符来进行订阅，如：\r\n[code]\r\nPSUBSCRIBE fm？*\r\n[/code]\r\n    这就订阅了fm开头的所有频道，但不会订阅fm这个频道。\r\n    PUNSUBSCRIBE同理。不说啦～', 1400509354, 12, 10, 0),
(51, 1, '李轩Lane', 'Memcached分布式部署方案设计（含PHP代码）', '一台Memcache通常不能满足我们的需求，这就需要分布式部署。Memcached分布式部署方案通常会采用两种方式，一种是普通Hash分布，一种是一致性Hash分布。本篇将以PHP作为客户端，来分析两种方案。', 'memcached分布式部署_memcached php_memcached集群', 'Memcached分布式部署方案通常会采用两种方式，一种是普通Hash分布，一种是一致性Hash分布。本篇将以PHP作为客户端，来分析两种方案。', 'memcached分布式部署,memcached php,memcached集群', 'PHP|Memcache|分布式', 404, '一台Memcache通常不能满足我们的需求，这就需要分布式部署。Memcached分布式部署方案通常会采用两种方式，一种是普通Hash分布，一种是一致性Hash分布。本篇将以PHP作为客户端，来分析两种方案。\r\n    一、普通Hash分布：\r\n[code]\r\n&lt;?php\r\nfunction test($key=''name''){\r\n    $md5 = substr(md5($key), 0, 8);\r\n    $seed = 31;\r\n    $hash = 0;\r\n    for($i=0; $i&lt;8; $i++){\r\n        $hash = $hash * $seed + ord($md5[$i]);\r\n    }\r\n    return $hash &amp; 0x7FFFFFFF;\r\n}\r\n\r\n$memcacheList = array(\r\n        array(''host''=&gt;''192.168.1.2'', ''port''=&gt;6379),\r\n        array(''host''=&gt;''192.168.1.3'', ''port''=&gt;6379),\r\n        array(''host''=&gt;''192.168.1.4'', ''port''=&gt;6379),\r\n        array(''host''=&gt;''192.168.1.5'', ''port''=&gt;6379),\r\n);\r\n$key = ''username'';\r\n$value = ''lane'';\r\n//根据KEY获取hash\r\n$hash = $this-&gt;test($key);\r\n$count = count($memcacheList);\r\n$memcache = $memcacheList[$hash % $count];\r\n$mc = new Memcached($memcache);\r\n$mc-&gt;set($key, $value);\r\n?&gt;\r\n[/code]\r\n    代码很简单，一个Hash函数，根据所需要的key，将他md5后取前8位，然后经过Hash算法返回一个整数。将这个整数对服务器总数求模。得到的就是服务器列表的编号。这种方式的缺点是服务器数量改变后，同一个key不同hash，将取不到值了。\r\n\r\n    二、一致性Hash分布\r\n    一致性Hash尽管也会造成数据的丢失，但是损失是最小的。\r\n    将2的32次方-1想象成一个圆环，服务器列表在上面排列。根据key通过hash算法求得在圆环上的位置，那么所需要的服务器的位置在key的位置前面最近的一个（顺时针）。\r\n[code]\r\n&lt;?php\r\nclass FlexiHash{\r\n    //服务器列表\r\n    private $serverList = array();\r\n    //是否排序\r\n    private $isSort = false;\r\n\r\n    /**\r\n     * Description: Hash函数，将传入的key以整数形式返回\r\n     * @param string $key\r\n     * @return int\r\n     */\r\n    private function myHash($key){\r\n        $md5 = substr(md5($key), 0, 8);\r\n        $seed = 31;\r\n        $hash = 0;\r\n        for($i=0; $i&lt;8; $i++){\r\n            $hash = $hash * $seed + ord($md5[$i]);\r\n        }\r\n        return $hash &amp; 0x7FFFFFFF;\r\n    }\r\n\r\n    /**\r\n     * Description: 添加新服务器\r\n     * @param $server\r\n     */\r\n    public function addServer($server){\r\n        $hash = $this-&gt;myHash($server);\r\n        if(!isset($this-&gt;serverList[$hash])){\r\n            $this-&gt;serverList[$hash] = $server;\r\n        }\r\n        $this-&gt;isSort = false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Description: 删除指定服务器\r\n     * @param $server\r\n     * @return bool\r\n     */\r\n    public function removeServer($server){\r\n        $hash = $this-&gt;myHash($server);\r\n        if(isset($this-&gt;serverList[$hash])){\r\n            unset($this-&gt;serverList[$hash]);\r\n        }\r\n        $this-&gt;isSort = false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Description: 根据要操作的KEY返回一个操作的服务器信息\r\n     * @param $key\r\n     * @return mixed\r\n     */\r\n    public function lookup($key){\r\n        //将指定的KEYhash出一个整数\r\n        $hash = $this-&gt;myHash($key);\r\n        if($this-&gt;isSort !== true){\r\n            krsort($this-&gt;serverList);\r\n            $this-&gt;isSort = false;\r\n        }\r\n        foreach($this-&gt;serverList as $key=&gt;$server){\r\n            if($key &lt;= $hash){\r\n                return $server;\r\n            }\r\n        }\r\n        return array_pop($this-&gt;serverList);\r\n    }\r\n}\r\n//使用方法\r\n$mc = new FlexiHash();\r\n$mc-&gt;addServer(''192.168.1.2'');\r\n$mc-&gt;addServer(''192.168.1.3'');\r\n$mc-&gt;addServer(''192.168.1.4'');\r\n$mc-&gt;addServer(''192.168.1.5'');\r\n\r\necho ''KEY=key1时，操作的服务器为：''.$mc-&gt;lookup(''key1'').''&lt;br&gt;'';\r\necho ''KEY=key1时，操作的服务器为：''.$mc-&gt;lookup(''key2'').''&lt;br&gt;'';\r\necho ''KEY=key1时，操作的服务器为：''.$mc-&gt;lookup(''key3'').''&lt;br&gt;'';\r\necho ''KEY=key1时，操作的服务器为：''.$mc-&gt;lookup(''key4'').''&lt;br&gt;'';\r\necho ''KEY=key1时，操作的服务器为：''.$mc-&gt;lookup(''key5'').''&lt;br&gt;'';\r\n?&gt;\r\n[/code]', 1400549934, 19, 14, 1),
(52, 11, '李轩Lane', '高性能网站架构方案', '高性能网站架构方案，本文谈了七点网站架构方案，用以优化网站响应时间，实现大型网站技术架构方案。无论是电子商务或者其他网站且可使用。', '网站架构_大型网站技术架构_高性能网站架构方案', '高性能网站架构方案，本文谈了七点网站架构方案，用以优化网站响应时间，实现大型网站技术架构方案。无论是电子商务或者其他网站且可使用。', '网站架构，大型网站技术架构，高性能网站架构方案', '架构', 179, '高性能网站架构方案，本文谈了七点网站架构方案，用以优化网站响应时间，实现大型网站技术架构方案。无论是电子商务或者其他网站且可使用。\r\n一、优化网站响应时间的架构方案：\r\n    网站能不能留的住用户，一方面是看内容，另一方面是看响应时间。通常有以下几个方式来降低网站响应时间：\r\n    1、减少HTTP请求。包括合并css和javascript。减少图片数量，比如利用css的偏移技术来在一个图片中选择不同的位置内容。利用浏览器的Cache功能，我们可以在头中声明是否被浏览器缓存。\r\n    2、动态内容静态化。比如永久生成HTML文件。生成静态文件并设定生存时间，到期后查询新的动态内容进行替换。\r\n    3、优化数据库。数据库的性能对于项目整体性能中是重中之重。设计良好的Mysql比乱糟糟的Mysql性能高出N个数量级，更别论再引入NOSQL了，比如Redis，MongoDB。\r\n    4、使用负载均衡。将请求合理的分发到更多服务器。\r\n    5、使用缓存。把花费时间和资源成本高昂的计算结果取出缓存起来，避免重复计算。比如在Mysql前面挡一层Memcached。比如生成一个文件，使用的时候include进来。再比如PHP中的OPCACHE等。\r\n\r\n二、压力测试的架构方案：\r\n    吞吐率是指单位时间内处理的请求数，单位reqs/s。最大吞吐率是指单位时间内能够处理的最大请求出。模拟足够多的人数和并发请求来测试最大吞吐率的方法叫做压力测试。比如Apache自带的ab（Apache Bench）。ab的参数很多，常用的有请求数（-n），并发用户数（-c），超时时间（-t），长连接（-k），附件一个Cookie（-c name=value）\r\n[code]\r\n$ab -c 10 -n 1000 http://localhost/\r\n[/code]\r\n\r\n三、长连接的架构方案：\r\n    每次请求都需要TCP的三次握手，握手完比表示连接正式联通，之后再发送数据。那么，把N个请求，就需要3N次握手，传递N次数据，得到N次响应，总共5N。如果把N个请求合成一个请求，就是3次握手，1次传递数据，1次返回响应，共5次。但是，有时候我们需要上一次响应的返回结果来发送新一轮的请求，在这个时候，合并请求并不好实现，这就需要长连接。使用起来很简单，在头中包含如下：\r\n[code]\r\nConnection: Keep-Alive\r\n[/code]\r\n    客户端和服务器端都可以设置长连接的最大时间，当两者不统一时以小的一方为准。开启长连接后进行压力测试：\r\n[code]\r\n$ab -c 10 -n 1000 http://localhost/\r\n[/code]\r\n    发现提升不止三五倍。本机是提升了8倍的性能。\r\n\r\n四、提高Mysql的响应速度的架构方案：\r\n    Handlerocker是日本的一位架构师开发。Mysql的一种插件。Handlerocker实现了绕过Mysql的SQL解析层。在Mysql5.1以上版本可以使用，详情可以查看Mysql手册。这里就不在阐述。\r\n\r\n五、Mysql主从复制的架构方案：\r\n    在分布式部署中，1台主库，N台从库。主库只写，从库只查。主库从库数据需要实现统一，这就是主从复制。优点是：\r\n    1、从库备份时，主库可以继续处理更新。\r\n    2、优化响应时间。\r\n    3、增加健壮性。主库挂了可以切换到从库作为备份。\r\n    主从复制的实现过程有三步，1个在主库，2个在从库：\r\n    1、主库服务器将用户对数据库更新的操作以二进制格式保存到Binary Log日志文件。然后Binlog Dump线程将Binary Log日志文件传输给从库服务器。\r\n    2、从库服务器通过一个I/O线程将主库服务器的Binary Log日志文件中的更新操作复制到一个叫做Relay Log中的中继日志文件中。\r\n    3、从库服务器通过另一个SQL线程Relay Log中继日志文件中的操作依次在本地执行，从而实现主从数据库之间数据的同步。\r\n    本篇只是简单的列出方案，详细的配置和实现步骤将在另一篇中写到。\r\n\r\n六、代理的架构方案：\r\n    读取内存的速度是读取硬盘的100000-1000000倍。把访问过的页面缓存在内存中，下次直接从内存中读取，可以有效加速。\r\n    1、传统代理。客户端发送请求给代理服务器，代理服务器向WEB服务器取到数据并返回给浏览器。代理服务器就是一个有大的存储空间的Cache。\r\n    2、反向代理。和传统代理原理类似，只是使用对象不同。传统代理的使用对象是客户端，反向代理的使用对象是服务器。用户通过反向代理访问Web服务器，Web服务器是隐藏起来的。不过用户不关心这些，权把代理服务器当作真实的Web服务器。反向代理有Vamish。\r\n\r\n七、异步计算的架构方案：\r\n    比较耗时的比如将用户上传的文件分发到多台机器，比如裁剪图片，视频转码等。可以使用异步方案。让用户无须等待计算结束而是先行返回结果。代表产品有和Memcache同一家的Gearman。关于Gearman的使用可以查看PHP手册。', 1400658261, 20, 15, 1);
INSERT INTO `info_article` (`id`, `mid`, `author`, `title`, `description`, `seo_title`, `seo_description`, `seo_keywords`, `tag`, `clicks`, `content`, `ctime`, `good_num`, `bad_num`, `recommend_type`) VALUES
(53, 1, '李轩Lane', 'Hash表：使用PHP实现Hash表功能', 'Hash表作为最重要的数据结构之一，也叫做散列表。使用PHP实现Hash表的功能。PHP可以模拟实现Hash表的增删改查。通过对key的映射到数组中的一个位置来访问。映射函数叫做Hash函数，存放记录的数组称为Hash表。', 'Hash表_PHP实现Hash表_Hash函数', 'Hash表作为最重要的数据结构之一，也叫做散列表。使用PHP实现Hash表的功能。PHP可以模拟实现Hash表的增删改查。通过对key的映射到数组中的一个位置来访问。映射函数叫做Hash函数，存放记录的数组称为Hash表。', 'Hash表,PHP实现Hash表,Hash函数', 'PHP|Hash', 106, 'Hash表作为最重要的数据结构之一，也叫做散列表。使用PHP实现Hash表的功能。PHP可以模拟实现Hash表的增删改查。通过对key的映射到数组中的一个位置来访问。映射函数叫做Hash函数，存放记录的数组称为Hash表。\r\nHash函数把任意长度的和类型的key转换成固定长度输出。不同的key可能拥有相同的hash。\r\nHash表的时间复杂度为O(1)\r\n[code]\r\n&lt;?php\r\n/**\r\n * hash表类\r\n * Class HashTable\r\n * Auth Lane\r\n * Mail lixuan868686@163.com\r\n * Blog http://www.lanecn.com\r\n */\r\nclass HashTable{\r\n    private $arr = array();\r\n    private $size = 10;\r\n    public function __construct(){\r\n        //SplFixedArray创建的数组比一般的Array()效率更高，因为更接近C的数组。创建时需要指定尺寸\r\n        $this-&gt;arr = new SplFixedArray($this-&gt;size);\r\n    }\r\n\r\n    /**\r\n     * Description: 简单hash算法。输入key，输出hash后的整数\r\n     * @param $key\r\n     * @return int\r\n     */\r\n    private function simpleHash($key){\r\n        $len = strlen($key);\r\n        //key中每个字符所对应的ASCII的值\r\n        $asciiTotal = 0;\r\n        for($i=0; $i&lt;$len; $i++){\r\n            $asciiTotal += ord($key[$i]);\r\n        }\r\n        return $asciiTotal % $this-&gt;size;\r\n    }\r\n\r\n    /**\r\n     * Description: 赋值\r\n     * @param $key\r\n     * @param $value\r\n     * @return bool\r\n     */\r\n    public function set($key, $value){\r\n        $hash = $this-&gt;simpleHash($key);\r\n        $this-&gt;arr[$hash] = $value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Description: 取值\r\n     * @param $key\r\n     * @return mixed\r\n     */\r\n    public function get($key){\r\n        $hash = $this-&gt;simpleHash($key);\r\n        return $this-&gt;arr[$hash];\r\n    }\r\n\r\n    public function getList(){\r\n        return $this-&gt;arr;\r\n    }\r\n\r\n    public function editSize($size){\r\n        $this-&gt;size = $size;\r\n        $this-&gt;arr-&gt;setSize($size);\r\n    }\r\n}\r\n?&gt;\r\n[/code]\r\n下面对我们的HashTable进行测试。\r\n[code]\r\n&lt;?php\r\n//测试1\r\n$arr = new HashTable();\r\nfor($i=0; $i&lt;15; $i++){\r\n    $arr-&gt;set(''key''.$i, ''value''.$i);\r\n}\r\nprint_r($arr-&gt;getList());\r\n//SplFixedArray Object\r\n//(\r\n//    [0] =&gt; value14\r\n//    [1] =&gt; value4\r\n//    [2] =&gt; value5\r\n//    [3] =&gt; value6\r\n//    [4] =&gt; value7\r\n//    [5] =&gt; value8\r\n//    [6] =&gt; value10\r\n//    [7] =&gt; value11\r\n//    [8] =&gt; value12\r\n//    [9] =&gt; value13\r\n//)\r\n//不同的key可能产生相同的hash值，那么赋值的时候后操作会覆盖前操作。\r\n\r\n//测试2\r\n$arr-&gt;editSize(15);\r\nfor($i=0; $i&lt;15; $i++){\r\n    $arr-&gt;set(''key''.$i, ''value''.$i);\r\n}\r\nprint_r($arr-&gt;getList());\r\n//SplFixedArray Object\r\n//(\r\n//    [0] =&gt; value14\r\n//    [1] =&gt; value4\r\n//    [2] =&gt; value0\r\n//    [3] =&gt; value1\r\n//    [4] =&gt; value2\r\n//    [5] =&gt; value3\r\n//    [6] =&gt; value10\r\n//    [7] =&gt; value11\r\n//    [8] =&gt; value12\r\n//    [9] =&gt; value13\r\n//    [10] =&gt; value14\r\n//    [11] =&gt; value9\r\n//    [12] =&gt;\r\n//    [13] =&gt;\r\n//    [14] =&gt;\r\n//)\r\n?&gt;\r\n[/code]\r\n    改变了值之后可以存放更多的元素。但是仍然存在不同的key可能产生相同的hash值，那么赋值的时候后操作会覆盖前操作的问题。这种冲突的问题我们来用拉链法解决。\r\n\r\n    拉链法解决冲突。拉链法解决冲突的做法是将所有的相同Hash值的key放在一个链表中，比如key3和key14在hash之后都是0，那么在数组的键为0的地方存储这两个值，形式是链表。如果不能理解我的文字，请看下面的示例，看一下打印信息就明白了。拉链法是什么，就是链表。\r\n    创建一个HashNode类，用来存储key和value的值，并且存储相同hash的另一个元素。在同一条链上，查找越后的元素越费时。时间复杂度为O(n).\r\n[code]\r\n&lt;?php\r\nclass HashNode{\r\n    public $key;\r\n    public $value;\r\n    public $nextNode;\r\n    public function __construct($key, $value, $nextNode=Null){\r\n        $this-&gt;key = $key;\r\n        $this-&gt;value = $value;\r\n        $this-&gt;nextNode = $nextNode;\r\n    }\r\n}\r\nclass NewHashTable{\r\n    private $arr;\r\n    private $size = 10;\r\n    public function __construct(){\r\n        $this-&gt;arr = new SplFixedArray($this-&gt;size);\r\n    }\r\n    private function simpleHash($key){\r\n        $asciiTotal = 0;\r\n        $len = strlen($key);\r\n        for($i=0; $i&lt;$len; $i++){\r\n            $asciiTotal += ord($key[$i]);\r\n        }\r\n        return $asciiTotal % $this-&gt;size;\r\n    }\r\n    public function set($key, $value){\r\n        $hash = $this-&gt;simpleHash($key);\r\n        if(isset($this-&gt;arr[$hash])){\r\n            $newNode = new HashNode($key, $value, $this-&gt;arr[$hash]);\r\n        }else{\r\n            $newNode = new HashNode($key, $value, null);\r\n        }\r\n        $this-&gt;arr[$hash] = $newNode;\r\n        return true;\r\n    }\r\n    public function get($key){\r\n        $hash = $this-&gt;simpleHash($key);\r\n        $current = $this-&gt;arr[$hash];\r\n        while(!empty($current)){\r\n            if($current-&gt;key == $key){\r\n                return $current-&gt;value;\r\n            }\r\n            $current = $current-&gt;nextNode;\r\n        }\r\n        return NULL;\r\n    }\r\n    public function getList(){\r\n        return $this-&gt;arr;\r\n    }\r\n}\r\n?&gt;\r\n[/code]\r\n    对我们新的HashTable进行测试\r\n[code]\r\n&lt;?php\r\n//测试1\r\n$newArr = new NewHashTable();\r\nfor($i=0; $i&lt;30; $i++){\r\n    $newArr-&gt;set(''key''.$i, ''value''.$i);\r\n}\r\nprint_r($newArr-&gt;getList());\r\nvar_dump($newArr-&gt;get(''key3''));\r\n//SplFixedArray Object\r\n//(\r\n//    [0] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key23\r\n//            [value] =&gt; value23\r\n//            [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key14\r\n//                    [value] =&gt; value14\r\n//                    [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key3\r\n//                            [value] =&gt; value3\r\n//                            [nextNode] =&gt;\r\n//                        )\r\n//\r\n//                )\r\n//\r\n//        )\r\n//\r\n//    [1] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key24\r\n//            [value] =&gt; value24\r\n//            [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key15\r\n//                    [value] =&gt; value15\r\n//                    [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key4\r\n//                            [value] =&gt; value4\r\n//                            [nextNode] =&gt;\r\n//                        )\r\n//\r\n//                )\r\n//\r\n//        )\r\n//\r\n//    [2] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key25\r\n//            [value] =&gt; value25\r\n//            [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key16\r\n//                    [value] =&gt; value16\r\n//                    [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key5\r\n//                            [value] =&gt; value5\r\n//                            [nextNode] =&gt;\r\n//                        )\r\n//\r\n//                )\r\n//\r\n//        )\r\n//\r\n//    [3] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key26\r\n//            [value] =&gt; value26\r\n//            [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key17\r\n//                    [value] =&gt; value17\r\n//                    [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key6\r\n//                            [value] =&gt; value6\r\n//                            [nextNode] =&gt;\r\n//                        )\r\n//\r\n//                )\r\n//\r\n//        )\r\n//\r\n//    [4] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key27\r\n//            [value] =&gt; value27\r\n//            [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key18\r\n//                    [value] =&gt; value18\r\n//                    [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key7\r\n//                            [value] =&gt; value7\r\n//                            [nextNode] =&gt;\r\n//                        )\r\n//\r\n//                )\r\n//\r\n//        )\r\n//\r\n//    [5] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key28\r\n//            [value] =&gt; value28\r\n//            [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key19\r\n//                    [value] =&gt; value19\r\n//                    [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key8\r\n//                            [value] =&gt; value8\r\n//                            [nextNode] =&gt;\r\n//                        )\r\n//\r\n//                )\r\n//\r\n//        )\r\n//\r\n//    [6] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key29\r\n//            [value] =&gt; value29\r\n//            [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key10\r\n//                    [value] =&gt; value10\r\n//                    [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key9\r\n//                            [value] =&gt; value9\r\n//                            [nextNode] =&gt;\r\n//                        )\r\n//\r\n//                )\r\n//\r\n//        )\r\n//\r\n//    [7] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key20\r\n//            [value] =&gt; value20\r\n//            [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key11\r\n//                    [value] =&gt; value11\r\n//                    [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key0\r\n//                            [value] =&gt; value0\r\n//                            [nextNode] =&gt;\r\n//                        )\r\n//\r\n//                )\r\n//\r\n//        )\r\n//\r\n//    [8] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key21\r\n//            [value] =&gt; value21\r\n//            [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key12\r\n//                    [value] =&gt; value12\r\n//                    [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key1\r\n//                            [value] =&gt; value1\r\n//                            [nextNode] =&gt;\r\n//                        )\r\n//\r\n//                )\r\n//\r\n//        )\r\n//\r\n//    [9] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key22\r\n//            [value] =&gt; value22\r\n//            [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key13\r\n//                    [value] =&gt; value13\r\n//                    [nextNode] =&gt; HashNode Object\r\n//(\r\n//    [key] =&gt; key2\r\n//                            [value] =&gt; value2\r\n//                            [nextNode] =&gt;\r\n//                        )\r\n//\r\n//                )\r\n//\r\n//        )\r\n//\r\n//)\r\n//string(6) &quot;value3&quot;\r\n?&gt;\r\n[/code]', 1400747962, 8, 8, 1),
(54, 1, '李轩Lane', '用PHP的实现一个高效的数据库（文件存储，NOSQL）', '本文用PHP开发高性能非关系型数据库，利用文件存储+hash表实现。提供php实现数据库的代码。本文将详细讲解用php开发数据库的案例。', 'PHP开发高性能非关系型数据库_php实现数据库_php开发数据库', '本文用PHP开发高性能非关系型数据库，利用文件存储+hash表实现。提供php实现数据库的代码。本文将详细讲解用php开发数据库的案例。', 'PHP开发高性能非关系型数据库,php实现数据库,php开发数据库', 'PHP|Hash|数据库', 136, '用文件的方式读写，一个文件是索引文件，另一个文件是真实的数据文件。\r\n索引文件分为2部分，第一部分是所有的指针，记录第二部分的位置；第二部分是索引记录。所有的索引指针：是记录所有相同Hash值的key的指针，它是一个链表结构，记录在数据文件的位置和同key的下一个值。\r\n索引记录中：每条记录有四部分，第一部分4个字节，是下一条索引的偏移量；第二部分是该记录的key，128字节；第三部分是数据偏移量，4个字节；第四部分是数据记录长度，4个字节。\r\n我们设定文件的存储上限为262144个。\r\n\r\n查找流程如下：\r\n1、根据key算出hash值，获取该hash值的链表在索引文件的第一部分（所有指针区）的位置。\r\n2、根据步骤一的位置，获取值，时间复杂度O(1)；\r\n2、根据步骤一中的值，找到索引文件中第二部分（索引记录）的位置，也就是和key相同hash值的所有指针的链表。顺着链表查找该key，获取该key在链表中存放的数据，数据只包含该key在索引文件中的位置，时间复杂度为O(n)；\r\n3、根据步骤二所获取的key在索引文件位置，得到索引文件中存放该key的信息。信息包含在真实数据文件中存放真实数据的位置。\r\n4、根据步骤三所获取的位置，在真实数据文件中获取数据，并返回给应用程序。\r\n\r\n测试结果：插入10000条耗时：793ms。查找10000条耗时：149ms。虽然这效率只有Redis的十分之一。。。但是请不要在意这些细节。。。\r\n\r\n代码做了注释，上述文字有些乱。代码只实现三个方法，一个插入（如果存在则跳过），一个是查找，一个是删除。\r\n\r\n思路来源：《PHP核心技术与最佳实践》一书。尊重作者，转载请保留该书名。\r\n[code]\r\n&lt;?php\r\n//Hash表中的元素指针个数，每个指针都是int，存储hash链表的文件偏移量\r\ndefine(''DB_BUCKET_SIZE'', 262144);\r\n//每条记录的key的长度\r\ndefine(''DB_KEY_SIZE'', 128);\r\n//一条索引记录的长度\r\ndefine(''DB_INDEX_SIZE'', DB_KEY_SIZE + 12);\r\n\r\n//成功-返回码\r\ndefine(''DB_SUCCESS'', 1);\r\n//失败-返回码\r\ndefine(''DB_FAILURE'', -1);\r\n//key重复-返回码\r\ndefine(''DB_KEY_EXISTS'', -2);\r\n\r\nclass DB{\r\n    private $idx_fp;\r\n    private $dat_fp;\r\n    private $closed;\r\n\r\n    /**\r\n     * Description: 打开数据库\r\n     * @param $pathName 数据文件的存放路径\r\n     * @return mixed\r\n     */\r\n    public function open($pathName){\r\n        $idx_path = $pathName . ''.idx'';\r\n        $dat_path = $pathName . ''.dat'';\r\n        if(!file_exists($idx_path)){\r\n            $init = true;\r\n            $mode = &quot;w+b&quot;;\r\n        }else{\r\n            $init = false;\r\n            $mode = ''r+b'';\r\n        }\r\n        $this-&gt;idx_fp = fopen($idx_path, $mode);\r\n        if(!$this-&gt;idx_fp){\r\n            return DB_FAILURE;\r\n        }\r\n        if($init){\r\n            //把0x00000000转换成无符号长整型的二进制\r\n            $elem = pack(''L'', 0x00000000);\r\n            for($i=0; $i&lt; DB_BUCKET_SIZE; $i++){\r\n                fwrite($this-&gt;idx_fp, $elem, 4);\r\n            }\r\n        }\r\n        $this-&gt;dat_fp = fopen($dat_path, $mode);\r\n        if(!$this-&gt;dat_fp){\r\n            return DB_FAILURE;\r\n        }\r\n\r\n        return DB_SUCCESS;\r\n    }\r\n\r\n    /**\r\n     * Description: Times33 Hash算法\r\n     * @param $key\r\n     * @return int\r\n     */\r\n    private function times33Hash($key){\r\n        $len = 8;\r\n        $key = substr(md5($key), 0, $len);\r\n        $hash = 0;\r\n        for($i=0; $i&lt;$len; $i++){\r\n            $hash += 33 * $hash + ord($key[$i]);\r\n        }\r\n        //0x7FFFFFFF：一个十六进制的数是4bit，8个就是32位，就是4字节，和一个int一样大。而F是1111，7是0111，那么这个十六进制的数就是头为0，其余为1的，首位是符号位，也就是说7fffffff是最大的整数。\r\n        //&amp; 0x7fffffff 可以保证返回的数是正整数\r\n        return $hash &amp; 0x7FFFFFFF;\r\n    }\r\n\r\n    /**\r\n     * Description: 插入记录\r\n     * @param $key\r\n     * @param $value\r\n     */\r\n    public function add($key, $value){\r\n        $offset = ($this-&gt;times33Hash($key) % DB_BUCKET_SIZE) * 4;\r\n\r\n        $idxoff = fstat($this-&gt;idx_fp);\r\n        $idxoff = intval($idxoff[''size'']);\r\n\r\n        $datoff = fstat($this-&gt;dat_fp);\r\n        $datoff = intval($datoff[''size'']);\r\n\r\n        $keylen = strlen($key);\r\n        $vallen = strlen($value);\r\n        if($keylen &gt; DB_KEY_SIZE){\r\n            return DB_FAILURE;\r\n        }\r\n        //0表示这是最后一个记录，该链再无其他记录。\r\n        $block = pack(''L'', 0x00000000);\r\n        //键值\r\n        $block .= $key;\r\n        //如果键值的长度没有达到最大长度，则用0填充\r\n        $space = DB_KEY_SIZE - $keylen;\r\n        for($i=0; $i&lt;$space; $i++){\r\n            $block .= pack(''C'', 0x00);\r\n        }\r\n        //数据所在文件的偏移量\r\n        $block .= pack(''L'', $datoff);\r\n        //数据记录的长度\r\n        $block .= pack(''L'', $vallen);\r\n        //尽管SEEK_SET是默认值，但是显式声明了就不怕以后官方会改变了-.-\r\n        fseek($this-&gt;idx_fp, $offset, SEEK_SET);\r\n        //检测该key所对应的hash值是否存在了\r\n        $pos = @unpack(''L'', fread($this-&gt;idx_fp, 4));\r\n        $pos = $pos[1];\r\n        //如果key不存在\r\n        if($pos == 0){\r\n            fseek($this-&gt;idx_fp, $offset, SEEK_SET);\r\n            fwrite($this-&gt;idx_fp, pack(''L'', $idxoff), 4);\r\n\r\n            fseek($this-&gt;idx_fp, 0, SEEK_END);\r\n            fwrite($this-&gt;idx_fp, $block, DB_INDEX_SIZE);\r\n\r\n            fseek($this-&gt;dat_fp, 0, SEEK_END);\r\n            fwrite($this-&gt;dat_fp, $value, $vallen);\r\n\r\n            return DB_SUCCESS;\r\n        }\r\n        //如果key存在\r\n        $found = false;\r\n        while($pos){\r\n            fseek($this-&gt;idx_fp, $pos, SEEK_SET);\r\n            $tmp_block = fread($this-&gt;idx_fp, DB_INDEX_SIZE);\r\n            $cpkey = substr($tmp_block, 4, DB_KEY_SIZE);\r\n            //$cpkey==$key时返回0，小于返回负数，大于返回正数\r\n            if(!strncmp($cpkey, $key, $keylen)){\r\n                $dataoff = unpack(''L'', substr($tmp_block, DB_KEY_SIZE + 4, 4));\r\n                $dataoff = $dataoff[1];\r\n                $datalen = unpack(''L'', substr($tmp_block, DB_KEY_SIZE + 8, 4));\r\n                $datalen = $datalen[1];\r\n                $found = true;\r\n                break;\r\n            }\r\n            $prev = $pos;\r\n            $pos = @unpack(''L'', substr($tmp_block, 0, 4));\r\n            $pos = $pos[1];\r\n        }\r\n\r\n        if($found){\r\n            return DB_KEY_EXISTS;\r\n        }\r\n        fseek($this-&gt;idx_fp, $prev, SEEK_SET);\r\n        fwrite($this-&gt;idx_fp, pack(''L'', $idxoff), 4);\r\n        fseek($this-&gt;idx_fp, 0, SEEK_END);\r\n        fwrite($this-&gt;idx_fp, $block, DB_INDEX_SIZE);\r\n        fseek($this-&gt;dat_fp, 0, SEEK_END);\r\n        fwrite($this-&gt;dat_fp, $value, $vallen);\r\n        return DB_SUCCESS;\r\n    }\r\n\r\n    /**\r\n     * Description: 查询一条记录\r\n     * @param $key\r\n     */\r\n    public function get($key){\r\n        //计算偏移量，key的hash值对索引文件的大小求模，再乘4。因为每个链表指针大小为4\r\n        $offset = ($this-&gt;times33Hash($key) % DB_BUCKET_SIZE) * 4;\r\n        //SEEK_SET是默认的\r\n        fseek($this-&gt;idx_fp, $offset, SEEK_SET);\r\n        $pos = unpack(''L'', fread($this-&gt;idx_fp, 4));\r\n        $pos = $pos[1];\r\n\r\n        $found = false;\r\n        while($pos){\r\n            fseek($this-&gt;idx_fp, $pos, SEEK_SET);\r\n            $block = fread($this-&gt;idx_fp, DB_INDEX_SIZE);\r\n            $cpkey = substr($block, 4, DB_KEY_SIZE);\r\n\r\n            if(!strncmp($key, $cpkey, strlen($key))){\r\n                $dataoff = unpack(''L'', substr($block, DB_KEY_SIZE + 4, 4));\r\n                $dataoff = $dataoff[1];\r\n\r\n                $datalen = unpack(''L'', substr($block, DB_KEY_SIZE + 8, 4));\r\n                $datalen = $datalen[1];\r\n\r\n                $found = true;\r\n                break;\r\n            }\r\n            $pos = unpack(''L'', substr($block, 0, 4));\r\n            $pos = $pos[1];\r\n        }\r\n        if(!$found){\r\n            return null;\r\n        }\r\n        fseek($this-&gt;dat_fp, $dataoff, SEEK_SET);\r\n        $data = fread($this-&gt;dat_fp, $datalen);\r\n        return $data;\r\n    }\r\n\r\n    /**\r\n     * Description: 删除\r\n     * @param $key\r\n     */\r\n    public function delete($key){\r\n        $offset = ($this-&gt;times33Hash($key) % DB_BUCKET_SIZE) * 4;\r\n        fseek($this-&gt;idx_fp, $offset, SEEK_SET);\r\n        $head = unpack(''L'', fread($this-&gt;idx_fp, 4));\r\n        $head = $head[1];\r\n        $curr = $head;\r\n        $prev = 0;\r\n        $found = false;\r\n        while($curr){\r\n            fseek($this-&gt;idx_fp, $curr, SEEK_SET);\r\n            $block = fread($this-&gt;idx_fp, DB_INDEX_SIZE);\r\n\r\n            $next = unpack(''L'', substr($block, 0, 4));\r\n            $next = $next[1];\r\n\r\n            $cpkey = substr($block, 4, DB_KEY_SIZE);\r\n            if(!strncmp($key, $cpkey, strlen($key))){\r\n                $found = true;\r\n                break;\r\n            }\r\n            $prev = $curr;\r\n            $curr = $next;\r\n        }\r\n        if(!$found){\r\n            return DB_FAILURE;\r\n        }\r\n        //删除索引文件。\r\n        if($prev == 0){\r\n            fseek($this-&gt;idx_fp, $offset, SEEK_SET);\r\n            fwrite($this-&gt;idx_fp, pack(''L'', $next), 4);\r\n        }else{\r\n            fseek($this-&gt;idx_fp, $prev, SEEK_SET);\r\n            fwrite($this-&gt;idx_fp, pack(''L'', $next), 4);\r\n        }\r\n        return DB_SUCCESS;\r\n    }\r\n\r\n    public function close(){\r\n        if(!$this-&gt;closed){\r\n            fclose($this-&gt;idx_fp);\r\n            fclose($this-&gt;dat_fp);\r\n            $this-&gt;closed = true;\r\n        }\r\n    }\r\n}\r\n?&gt;\r\n[/code]\r\n\r\n测试，测试添加一万条和查找一万条：\r\n[code]\r\n&lt;?php\r\n//先include上面的类。。如果在同一个文件中就不用了。\r\n//测试\r\n$db = new DB();\r\n$db-&gt;open(''/var/www/data/'');\r\n\r\n$startTime = microtime(true);\r\n\r\n//插入测试...插入10000条：成功，耗时： 793.48206520081ms\r\n//for($i=0; $i&lt;10000; $i++){\r\n//    $db-&gt;add(''key''.$i, ''value''.$i);\r\n//}\r\n\r\n//查找测试...查找10000条：成功，耗时： 149.08313751221ms\r\nfor($i=0; $i&lt;10000; $i++){\r\n    $db-&gt;get(''key''.$i);\r\n}\r\n\r\n$endTime = microtime(true);\r\necho ''成功，耗时： '' . (($endTime - $startTime)*1000) . ''ms'';\r\n$db-&gt;close();\r\n?&gt;\r\n[/code]', 1400839724, 16, 11, 1),
(55, 10, '李轩Lane', 'Redis管道概念', 'Redis管道的概念类似与Liinux管道的概念，可以将多个命令合成一个命令，减少了多次的TCP三次握手。提高Redis在应用层的效率，节省传输时间。', 'Redis管道_Redis管道概念', 'Redis管道的概念类似与Liinux管道的概念，可以将多个命令合成一个命令，减少了多次的TCP三次握手。提高Redis在应用层的效率，节省传输时间。', 'Redis管道,Redis管道概念', 'Redis|管道', 71, 'Redis管道是大幅提升传输速度和用户体验的一个功能。Redis是使用TCP协议进行传输，当客户端发送一条命令之后，到服务器端接收到这个命令，这个过程是需要发送时间的。当服务器处理完命令返回结果给客户端的时候，这个是需要返回时间的。统称为往返时延。如果多条命令一次性发送过去，Redis服务器端全部处理好后一次性发送回客户端，那么就只需要花费一份的往返时延。这就是Redis的管道命令。Redis底层通信协议对管道命令提供了支持。如：\r\n[code]\r\n$ (echo -en &quot;PING\\r\\nPING\\r\\nPING\\r\\n&quot;; sleep 1) | nc localhost 6379\r\n+PONG\r\n+PONG\r\n+PONG\r\n[/code]\r\n    关于管道的具体使用，后期在详细说明。这里只需要知道有这个概念即可。', 1400992957, 16, 13, 0),
(56, 10, '李轩Lane', 'Redis在PHP中的应用', 'PHP redis的使用方法详解。php上使用redis主要有两种方式，一种是Predis，一种是phpredis。phpredis是php的一个扩展，以C语言编写的高性能链表。本文讲解Predis的使用。Predis是PHP语言编写。', 'php redis_php redis扩展_php redis使用', 'PHP redis的使用方法详解。php上使用redis主要有两种方式，一种是Predis，一种是phpredis。phpredis是php的一个扩展，以C语言编写的高性能链表。本文讲解Predis的使用。Predis是PHP语言编写。', 'php redis,php redis扩展,php redis使用', 'PHP|Redis', 139, 'PHP redis的使用方法详解。php上使用redis主要有两种方式，一种是Predis，一种是phpredis。phpredis是php的一个扩展，以C语言编写的高性能链表。本文讲解Predis的使用。Predis是PHP语言编写。\r\n\r\n    PHP redis的使用方法详解。php上使用redis主要有两种方式，一种是Predis，一种是phpredis。phpredis是php的一个扩展，以C语言编写的高性能链表。本文讲解Predis的使用。\r\n    Predis是Redis官方推出的由PHP原生语言编写的客户端。由于Predis采用了命名空间的方式，所以Predis要求PHP版本最低为5.3。    \r\n    Predis开源且托管在GitHub上https://github.com/nrk/predis/。下载整个文件夹复制到项目目录即可。\r\n[code]\r\n//引入autoload.php文件\r\nrequire ''./predis/autoload.php'';\r\n\r\n//实例化\r\n$redis = New Predis\\Client();\r\n/*这个是简化版，等同于$redis = New Predis\\Client(array(\r\n * ''scheme'' =&gt; ''tcp'',\r\n * ''host'' =&gt; ''127.0.0.1''\r\n * ''port'' =&gt; 6379\r\n *));\r\n */\r\n\r\n//GET\r\n$redis-&gt;get(''key'');\r\n\r\n//LPUSH\r\n$redis-&gt;lpush(''key'', ''1'', ''2'', ''3'');\r\n\r\n//MSET 相当于$redis-&gt;MSET(''article:1:title'', ''biaoti'', ''article:1:content'', ''neirong'', ''ctime'', ''shijian'');\r\n$article = array(''article:1:title''=&gt;''biaoti'', ''article:1:content''=&gt;''neirong'', ''article:1:ctime''=&gt;''shijian'');\r\n$redis-&gt;MSET(''key'', $article);\r\n\r\n//MGET\r\n$articleKeys = array_keys($article);\r\n$redis-&gt;MGET($articleKeys);\r\n\r\n//SORT\r\n//SORT articleList BY article:*-&gt;time LIMIT 0 10 GET article:*-&gt;title GET # DESC ALPHA STORE storeKey\r\n$sort = array(\r\n    ''by'' =&gt; ''article:*-&gt;time'',\r\n    ''limit'' =&gt; array(0, 10),\r\n    ''get'' =&gt; array(''article:*-&gt;title'', ''#''),\r\n    ''sort'' =&gt; ''desc'',\r\n    ''alpha'' =&gt; true,\r\n    ''store'' =&gt; ''storeKey''\r\n);\r\n[/code]\r\n    Predis的封装之后，用起来非常方便，关联数组的引入是开发效率非常高的。更多的内容可以参考Predis文档：https://github.com/nrk/predis/blob/v0.8/FAQ.md', 1401113824, 14, 18, 0),
(57, 1, '李轩Lane', 'PHP的命名空间', 'PHP命名空间是PHP5.3开始支持。本篇讲解PHP命名空间用法和PHP命名空间详解。它的诞生使的我们在一个文件中可以使用多个同名的类而不冲突。', 'PHP命名空间_PHP命名空间用法_PHP命名空间详解', 'PHP命名空间是PHP5.3开始支持。本篇讲解PHP命名空间用法和PHP命名空间详解。它的诞生使的我们在一个文件中可以使用多个同名的类而不冲突。', 'PHP命名空间,PHP命名空间用法,PHP命名空间详解', 'PHP|命名空间', 102, 'PHP命名空间是PHP5.3开始支持。本篇讲解PHP命名空间用法和PHP命名空间详解。它的诞生使的我们在一个文件中可以使用多个同名的类而不冲突。\r\n    好处：我们的项目有一个记录日志文件的类，叫做Log。然后我们又必须要引入另一个代码包，这个代码包里也有一个叫做Log的类。那么在一个文件中，我们记录日志的又需要给两个类都写一条日志。可以类同名了，怎么办？这个时候，命名空间应运而生。在Java等语言中命名空间是很早就已经提供了支持，而我大PHP一直到5.3才对命名空间提供了支持。\r\n    示例一：\r\n文件index.php\r\n[code]\r\n&lt;?php\r\ninclude ''test.php'';\r\n\r\nclass index{\r\n    public function a(){\r\n        echo basename(__FILE__);\r\n        echo ''&lt;br&gt;'';\r\n        echo __CLASS__ . '' : '' . __METHOD__;\r\n    }\r\n}\r\n$obj = new index();\r\n$obj-&gt;a();\r\necho ''&lt;br&gt;'';\r\n$obj1 = new test\\index();\r\n$obj1-&gt;a();\r\n?&gt;\r\n[/code]\r\n文件test.php\r\n[code]\r\n&lt;?php\r\nnamespace test;\r\nclass index{\r\n    public function a(){\r\n        echo basename(__FILE__);\r\n        echo ''&lt;br&gt;'';\r\n        echo __CLASS__ . '' : '' . __METHOD__;\r\n    }\r\n}\r\n?&gt;\r\n[/code]\r\n    我们给index.php不设置命名空间，对test.php设置命名空间，名为test。运行index.php。\r\n结果：\r\n[code]\r\nindex.php\r\nindex : index::a\r\ntest.php\r\ntest\\index : test\\index::a\r\n[/code]\r\n    我们看到了，同名的类也可以运行而不冲突了。\r\n\r\n    示例二：\r\n文件index.php\r\n[code]\r\n&lt;?php\r\nnamespace index;\r\ninclude ''test.php'';\r\n\r\nclass index{\r\n    public function a(){\r\n        echo basename(__FILE__);\r\n        echo ''&lt;br&gt;'';\r\n        echo __CLASS__ . '' : '' . __METHOD__;\r\n    }\r\n}\r\n$obj = new index();\r\n$obj-&gt;a();\r\necho ''&lt;br&gt;'';\r\n$obj1 = new \\test\\index();\r\n$obj1-&gt;a();\r\n?&gt;\r\n[/code]\r\n文件test.php\r\n[code]\r\n&lt;?php\r\nnamespace test;\r\nclass index{\r\n    public function a(){\r\n        echo basename(__FILE__);\r\n        echo ''&lt;br&gt;'';\r\n        echo __CLASS__ . '' : '' . __METHOD__;\r\n    }\r\n}\r\n?&gt;\r\n[/code]\r\n    我们给index.php设置命名空间，名为index，对test.php设置命名空间，名为test。运行index.php。\r\n结果：\r\n[code]\r\nindex.php\r\nindex\\index : index\\index::a\r\ntest.php\r\ntest\\index : test\\index::a\r\n[/code]\r\n    比较示例一和二，不对index.php设置命名空间，即该文件是整个PHP全局命名空间下面的一个文件，那么使用test\\index()即可，如果对index.php设置命名空间，即在其他的命名空间中使用命名空间，就要多一个“\\”，就要使用\\test\\index()。\r\n\r\n示例三：\r\n文件index.php\r\n[code]\r\n&lt;?php\r\nnamespace index;\r\n\r\ninclude ''namespace.php'';\r\n\r\nuse \\test\\test1\\test2 as test2;\r\n\r\nclass index{\r\n    public function a(){\r\n        echo basename(__FILE__);\r\n        echo ''&lt;br&gt;'';\r\n        echo __CLASS__ . '' : '' . __METHOD__;\r\n    }\r\n}\r\n\r\n$obj = new index();\r\n$obj-&gt;a();\r\n\r\necho ''&lt;br&gt;'';\r\n\r\n$obj1 = new \\test\\test1\\test2\\index();\r\n$obj1-&gt;a();\r\n\r\necho ''&lt;br&gt;'';\r\n\r\n$obj1 = new test2\\index();\r\n$obj1-&gt;a();\r\n[/code]\r\n文件test.php\r\n[code]\r\n&lt;?php\r\nnamespace test\\test1\\test2;\r\nclass index{\r\n    public function a(){\r\n        echo basename(__FILE__);\r\n        echo ''&lt;br&gt;'';\r\n        echo __CLASS__ . '' : '' . __METHOD__;\r\n    }\r\n}\r\n[/code]\r\n结果：\r\n[code]\r\nindex.php\r\nindex\\index : index\\index::a\r\ntest.php\r\ntest\\test1\\test2\\index : test\\test1\\test2\\index::a\r\ntest.php\r\ntest\\test1\\test2\\index : test\\test1\\test2\\index::a\r\n[/code]\r\n    这说明了什么？别名！用过SQL吧。\r\n[code]\r\nselect COUNT(*) as `count` from `tebleName`\r\n[/code]\r\n    嗯，一个意思。\\test\\test1\\test2这个名字太长了，就别名为test2就好了。使用了use之后呢，这个命名空间就想到于是在index这个命名空间下面了，而不是全局命名空间的一员了，所以使用test2\\index()，而不是\\test2\\index()。\r\n\r\n    别名时在PHP代码编译的时候执行的，而变量的解析则要更晚。也就是说不能对变量运用use关键字。示例如下（摘自官方手册示例）：\r\n[code]\r\n&lt;?php\r\nuse My\\Full\\Classname as Another, My\\Full\\NSname;\r\n\r\n$obj = new Another; // 实例化一个 My\\Full\\Classname 对象\r\n$a = ''Another'';\r\n$obj = new $a;      // 实际化一个 Another 对象\r\n[/code]', 1402203105, 12, 10, 0),
(58, 1, '李轩Lane', 'XHProf的安装和使用（PHP性能测试神器）', 'XHProf是Facebook开发的性能调试工具，帮助我们的PHP程序性能调优，更加健壮。XHProf安装和使用方法将在本章讲解。XHProf是PHP的PECL扩展。没有XDeBug那些耗费资源，更加的小巧。', 'XHProf安装_XHProf使用_XHProf详解', 'XHProf是Facebook开发的性能调试工具，帮助我们的PHP程序性能调优，更加健壮。XHProf安装和使用方法将在本章讲解。XHProf是PHP的PECL扩展。', 'XHProf安装,XHProf使用,XHProf详解', 'PHP|XHProf', 205, 'XHProf是Facebook开发的性能调试工具，帮助我们的PHP程序性能调优，更加健壮。XHProf安装和使用方法将在本章讲解。XHProf是PHP的PECL扩展。没有XDeBug那些耗费资源，更加的小巧。\r\n    流程：程序开头打点，结尾打点。那么XHProf机会记录在两个点之间的所有代码响应时所耗费的时间、内存、CPU等各项指标，我们也可以知道一次请求调用了多少次MySQL，多少次Memcache，更加直观的指明优化道路。\r\n    安装：\r\n[code]\r\n------------下载并编译PHP-XHProf源码------------\r\nwget http://pecl.php.net/get/xhprof-0.9.4.tgz\r\ntar -zxvf xhprof-0.9.4.tgz\r\ncd xhprof-0.9.4\r\ncd extension\r\nphpize\r\n./configure --enable-xhprof\r\nmake\r\nmake test\r\nsudo make install\r\n\r\n------------修改php.ini---------------\r\nsudo vim /etc/php.ini\r\n#在php.ini最下方加入以下：\r\nextension=xhprof.so\r\nxhprof.output_dir=&quot;/var/www/xhprof&quot;\r\n\r\n-----------重启Apache--------------\r\nsudo apache restart\r\n[/code]\r\n\r\n    进入刚才解压的安装包文件夹中，将xhprof_lib和xhprof_html复制到项目目录下。\r\n    接下来，建立一个头文件head.php，这是要打两个点中的开头的点：\r\n[code]\r\n//head.php\r\n&lt;?php\r\nif(extension_loaded(''xhprof'')){\r\n    //载入下载的XHPROF包中的2个文件夹\r\n    include_once ''xhprof_lib/utils/xhprof_lib.php'';\r\n    include_once ''xhprof_lib/utils/xhprof_runs.php'';\r\n    xhprof_enable(XHPROF_FLAGS_CPU + XHPROF_FLAGS_MEMORY);\r\n}\r\n[/code]\r\n\r\n    再建立一个底部文件foot.php，这是要打两个点中的结尾的点：\r\n[code]\r\n//foot.php\r\n&lt;?php\r\nif(extension_loaded(''xhprof'')){\r\n    $ns = ''myXhprof'';\r\n    //关闭profiler\r\n    $xhprofData = xhprof_disable();\r\n    //实例化类\r\n    $xhprofRuns = new XHProfRuns_Default();\r\n    $runId = $xhprofRuns-&gt;save_run($xhprofData, $ns);\r\n    //前端展示库的URL\r\n    $url = ''http://localhost/xhprof_html/index.php'';\r\n    $url .= ''?run=%s&amp;source=%s'';\r\n    //变量替换\r\n    $url = sprintf($url, $runId, $ns);\r\n    //输入URL\r\n    echo ''&lt;a href=&quot;''.$url.''&quot; target=&quot;_blank&quot;&gt;查看结果&lt;/a&gt;'';\r\n}\r\n[/code]\r\n\r\n    使用的最后一步：打点。现在我们建立一个测试文件index.php。测试我大Hello World。\r\n[code]\r\n//index.php\r\n&lt;?php\r\ninclude_once ''head.php'';\r\necho ''Hello World'';\r\ninclude_once ''foot.php'';\r\n[/code]\r\n   \r\n    可以看到，在http://localhost/index.php中，最下面是我们在foot.php中写的“查看结果”，点击进去，可以看到本次请求所使用到的所有函数的列表，每个函数所耗费的时间、CPU、Memory等信息，点击第一栏可以根据所选排序。点击[View Full Callgraph]可以看到由本列表所生成的流程图，从入口到哪个函数，又到哪个函数，这个函数调用了哪个函数，这个函数调用了多少次Memcache等，一幕了然。减少MC的调用，减少这个，减少那个，请求的响应速度能不快吗？\r\n\r\n技巧：\r\n    我有1000个文件，现在我需要用XHProf检测一下我整个项目，难道要每个文件头部和尾部都要加上include吗？\r\n    在php.ini中添加：\r\n[code]\r\nauto_prepend_file = /var/www/head.php\r\nauto_append_file = /var/www/foot.php\r\n[/code]\r\n    或者在.htaccess中添加\r\n[code]\r\nphp_value auto_prepend_file = /var/www/head.php\r\nphp_value auto_append_file = /var/www/foot.php\r\n[/code]\r\n\r\n报错：\r\n1、点击[View Full Callgraph]查看图片的时候报错：failed to execute cmd：&quot; dot -Tpng&quot;. stderr：`sh： dot：command not found`。\r\n原因：原因：未安装图形化工具\r\n解决：\r\n[code]\r\n//红帽系列\r\nyum install graphviz\r\n//Ununtu\r\napt-get install graphviz\r\n//OS X\r\nbrew install graphviz\r\n[/code]', 1402647138, 351, 7, 2),
(59, 6, '李轩Lane', '百度PHP面试，流程与面试问题', '百度PHP面试会问什么？很荣幸参加了百度PHP岗位面试，互联网自由与分享精神，不涉及公司机密的百度PHP面试题公布。望能帮助到将百度PHP面试的同学', '百度PHP面试_百度PHP面试题_百度PHP岗位面试', '百度PHP面试会问什么？很荣幸参加了百度PHP岗位面试，互联网自由与分享精神，不涉及公司机密的百度PHP面试题公布。望能帮助到将百度PHP面试的同学', '百度PHP面试,百度PHP面试题,百度PHP岗位面试', 'PHP|面试|百度', 266, '很荣幸参加了百度PHP岗位面试，百度PHP面试会问什么是大家最关心的，鉴于互联网自由与分享精神，不涉及公司机密的百度PHP面试题公布。望能帮助到将去百度PHP面试同学。\r\n    Ps：1、部门省略。2、涉及公司情况的省略。时隔一个月，具体的已经记不大清楚了，仅供参考。\r\n\r\n一面：技术面\r\n    1、介绍自己\r\n    2、介绍项目\r\n    3、分布式部署方式\r\n    4、项目优化经验\r\n    5、XHProf\r\n    6、大文件，里面都是数字，一行一个，排序\r\n    6、以上5点的扩展\r\n\r\n二面：技术面\r\n    1、介绍项目\r\n    2、XHProf\r\n    3、介绍项目优化经验\r\n    4、写几个PHP自带的函数\r\n    5、一个关联数组（KEY-VALUE键值对，KEY是字符串，VALUE是整数），在不使用PHP自带函数的前提下，对数组排序，然后问时间复杂度。最后问写完后问还能不能优化，怎么优化。\r\n    6、不断的边聊边扩展。\r\n\r\n三面：技术面\r\n    1、画一下项目的流程图\r\n    2、介绍一下项目\r\n    3、项目优化经验\r\n    4、为什么离职\r\n    5、你想做什么\r\n    6、边聊便扩展\r\n\r\n等通知...\r\n\r\n邮件告知面试已过...\r\n\r\nHR电话谈薪资和offer...', 1403882929, 6, 0, 2),
(62, 1, '李轩Lane', '四则运算：中缀表达式转后缀表达式', '四则运算表达式，我们书面使用的叫做中缀表达式，而计算器，却更加喜欢后缀表达，括号优先级，加减乘除优先级等使得运算中缀四则表达式变得困难。这个时候引入了一种计算机喜欢的格式，叫做后缀表达式。本文以PHP代码，实现中缀表达式转后缀表达式的逻辑。', '中缀表达式_后缀表达式_中缀表达式转后缀表达式', '四则运算表达式，我们书面使用的叫做中缀表达式，而计算器，却更加喜欢后缀表达，括号优先级，加减乘除优先级等使得运算中缀四则表达式变得困难。这个时候引入了一种计算机喜欢的格式，叫做后缀表达式。本文以PHP代码，实现中缀表达式转后缀表达式的逻辑。', '中缀表达式,后缀表达式,中缀表达式转后缀表达式', 'PHP|后缀|中缀', 73, '<p>&nbsp; &nbsp; 四则运算表达式，我们书面使用的叫做中缀表达式，而计算器，却更加喜欢后缀表达，括号优先级，加减乘除优先级等使得运算中缀四则表达式变得困难。这个时候引入了一种计算机喜欢的格式，叫做后缀表达式。本文以PHP代码，实现中缀表达式转后缀表达式的逻辑。</p><p>&nbsp; &nbsp; 本文以PHP为代码环境，有人会说高级语言直接写表达式就好了，它们会算，可是他们为什么会算，怎么算的，还是需要把中缀表达式转为后缀表达式。因此本文代码只是模拟一个逻辑。</p><p>&nbsp; &nbsp; 比如：传统的四则运算表达式（中缀表达式）是9 + ( 3 - 1 ) * 3 + 10 / 2，对应的后缀表达式就是9 3 1 - 3 * + 10 2 / +。</p><p>&nbsp; &nbsp; 转换逻辑：一个字符一个字符的输入，如果是数字则直接输出；如果是左括号则直接入栈；如果是右括号则开始出栈，直到遇到第一次左括号为止；如果是加减乘除，则判断，如果栈顶也是符号，且输入的符号的优先级不高于栈顶的符号优先级，则全部出栈，否则该输入的符号入栈。</p><p>[code]</p><p>&lt;?php</p><p>/**</p><p>&nbsp;* 将输入的字符按照中缀表达式转后缀表达式的规则处理</p><p>&nbsp;* @param $str 输入的字符</p><p>&nbsp;* @param $stack 栈</p><p>&nbsp;* @param $newStrList 新的表达式</p><p>&nbsp;*/</p><p>function suffix($str, &amp;$stack, &amp;$newStrList){</p><p>&nbsp; &nbsp; //如果是数字则输出</p><p>&nbsp; &nbsp; if(is_numeric($str)){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; $newStrList .= $str . &#39; &#39;;</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; //如果是左括号则入栈</p><p>&nbsp; &nbsp; else if($str == &#39;(&#39;){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; $stack[] = $str;</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; //如果是右括号则将最近的左括号之前的所有数据出栈</p><p>&nbsp; &nbsp; else if($str == &#39;)&#39;){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; while($arrPop = array_pop($stack)){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if($arrPop == &#39;(&#39;){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $newStrList .= $arrPop . &#39; &#39;;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; //如果是加减乘除则判断与栈顶符号优先级</p><p>&nbsp; &nbsp; else if(in_array($str, array(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;)) &amp;&amp; count($stack) &gt; 0){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; $key &nbsp;= (count($stack) - 1);</p><p>&nbsp; &nbsp; &nbsp; &nbsp; if(in_array($stack[$key], array(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;))){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //该符号优先级不高于栈顶符号的</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(checkPriority($str, $stack[$key]) != 1){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for($i=$key; $i&gt;=0; $i--){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if($stack[$i] == &#39;(&#39;){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $newStrList .= $stack[$i] . &#39; &#39;;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unset($stack[$i]);</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $stack = array_values($stack);</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; &nbsp; &nbsp; //本次的符号入栈</p><p>&nbsp; &nbsp; &nbsp; &nbsp; $stack[] = $str;</p><p>&nbsp; &nbsp; }else{</p><p>&nbsp; &nbsp; &nbsp; &nbsp; $stack[] = $str;</p><p>&nbsp; &nbsp; }</p><p>}</p><p><br/></p><p>/**</p><p>&nbsp;* 判断运算符的优先级</p><p>&nbsp;* @param $operatorA</p><p>&nbsp;* @param $operatorB</p><p>&nbsp;* @return A大于B返回1，A等于B返回0，A小于B返回-1</p><p>&nbsp;*/</p><p>function checkPriority($operatorA, $operatorB){</p><p>&nbsp; &nbsp; switch($operatorA){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; case &#39;+&#39;:</p><p>&nbsp; &nbsp; &nbsp; &nbsp; case &#39;-&#39;:</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if($operatorB == &#39;+&#39; || $operatorB == &#39;-&#39;){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }else if($operatorB == &#39;*&#39; || $operatorB == &#39;/&#39;){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -1;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; case &#39;*&#39;:</p><p>&nbsp; &nbsp; &nbsp; &nbsp; case &#39;/&#39;:</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if($operatorB == &#39;+&#39; || $operatorB == &#39;-&#39;){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 1;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }else if($operatorB == &#39;*&#39; || $operatorB == &#39;/&#39;){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; default:</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit(&#39;error&#39;);</p><p>&nbsp; &nbsp; }</p><p>}</p><p>//栈</p><p>$stack = array();</p><p>//待转换的表达式</p><p>$strList = &#39;9 + ( 3 - 1 ) * 3 + 10 / 2&#39;;</p><p>//新的表达式</p><p>$newStrList = &#39;&#39;;</p><p>$strList = explode(&#39; &#39;, $strList);</p><p>foreach($strList as $str){</p><p>&nbsp; &nbsp; if($str != &#39; &#39;){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; suffix($str, $stack, $newStrList);</p><p>&nbsp; &nbsp; }</p><p>}</p><p>//数组反转</p><p>while($s = array_pop($stack)){</p><p>&nbsp; &nbsp; $newStrList .= $s . &#39; &#39;;</p><p>}</p><p>echo $newStrList;</p><p>[/code]</p><p><br/></p>', 1404441511, 0, 0, 0);
INSERT INTO `info_article` (`id`, `mid`, `author`, `title`, `description`, `seo_title`, `seo_description`, `seo_keywords`, `tag`, `clicks`, `content`, `ctime`, `good_num`, `bad_num`, `recommend_type`) VALUES
(63, 1, '李轩Lane', '二叉树遍历算法', '二叉树遍历是二叉树上最重要的运算之一，是二叉树上进行其它运算之基础。二叉树遍历算法，主要有三种二叉树遍历算法，分别是前序、中序、后序算法。不常用的还有层序遍历算法。', '二叉树遍历_二叉树遍历算法_二叉树三种遍历算法', '二叉树遍历是二叉树上最重要的运算之一，是二叉树上进行其它运算之基础。二叉树遍历算法，主要有三种二叉树遍历算法，分别是前序、中序、后序算法。不常用的还有层序遍历算法。', '二叉树遍历,二叉树遍历算法,二叉树三种遍历算法', 'PHP|二叉树|算法', 89, '<p>&nbsp; &nbsp; 二叉树遍历，是值从根节点出发，按照某种次序依次访问二叉树中的所有节点，使得每个节点被访问一次且仅被访问依次。</p><p style="text-align: center;"><img src="http://lanecn-upload.stor.sinaapp.com/image/20140709_1404896527_874807.gif" title="20140709_1404896527_874807.gif" alt="tupan062.gif" style="text-align: center; white-space: normal;"/></p><p style="text-align: center;">图是百度搜的。。。谢谢提供图的英雄。。<br/></p><p>&nbsp; &nbsp; 前序遍历二叉树：如果二叉树为空则返回，若二叉树非空，则先遍历左树，再遍历右树，遍历顺序为ABCDEGF。</p><p>&nbsp; &nbsp; 中序遍历二叉树：如果二叉树为空则返回，若二叉树非空，则从根节点开始，中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树，遍历顺序为CBEGDFA。</p><p>&nbsp; &nbsp; 后序遍历二叉树：如果二叉树为空则返回，若二叉树非空，则从左到右先叶子后节点的访问遍历访问左右子树，最后是访问根节点。访问顺序为CGEFDBA。</p><p>&nbsp; &nbsp; 层序遍历二叉树：如果二叉树为空则返回，若二叉树非空，则从树的第一层，也就是根节点开始访问，从上而下逐层遍历，在同一层中，按照从左到右的顺序对节点逐个访问。访问顺序为ABCDEFG。</p><p><br/></p><p>&nbsp; &nbsp; 现在，我们用PHP代码，来遍历二叉树结构。二叉树是放一个大数组，每一个节点都有三个字段，data表示这个节点的值，lChild表示这个节点的左边子节点，rChild表示这个节点的右边子节点。二叉树的结构我们用上面那张图。</p><p><br/></p><p>二叉树结构代码如下：</p><p>[code]</p><p>&lt;?php</p><p>//二叉树</p><p>$arr = array(</p><p>&nbsp; &nbsp; &#39;data&#39; =&gt; &#39;A&#39;,</p><p>&nbsp; &nbsp; &#39;lChild&#39; =&gt; array(</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &#39;data&#39; =&gt; &#39;B&#39;,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &#39;lChild&#39; =&gt; array(</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;data&#39; =&gt; &#39;C&#39;,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;lChild&#39; =&gt; array(),</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;rChild&#39; =&gt; array(),</p><p>&nbsp; &nbsp; &nbsp; &nbsp; ),</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &#39;rChild&#39; =&gt; array(</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;data&#39; =&gt; &#39;D&#39;,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;lChild&#39; =&gt; array(</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;data&#39; =&gt; &#39;E&#39;,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;lChild&#39; =&gt; array(),</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;rChild&#39; =&gt; array(</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;data&#39; =&gt; &#39;G&#39;,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;lChild&#39; =&gt; array(),</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;rChild&#39; =&gt; array(),</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ),</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ),</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;rChild&#39; =&gt; array(</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;data&#39; =&gt; &#39;F&#39;,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;lChild&#39; =&gt; array(),</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;rChild&#39; =&gt; array(),</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ),</p><p>&nbsp; &nbsp; &nbsp; &nbsp; ),</p><p>&nbsp; &nbsp; ),</p><p>&nbsp; &nbsp; &#39;rChild&#39; =&gt; array(),</p><p>);</p><p>[/code]</p><p><br/></p><p>遍历算法一：前序遍历二叉树<br/></p><p>[code]</p><p>&lt;?php</p><p>//前序遍历二叉树算法</p><p>echo &#39;前序遍历二叉树算法：&#39;;</p><p>PreOrderTraverse($arr);</p><p>echo &#39;&lt;Br&gt;&#39;;</p><p>function PreOrderTraverse($node){</p><p>&nbsp; &nbsp; if(empty($node)){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; return;</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; //输出值</p><p>&nbsp; &nbsp; print_r($node[&#39;data&#39;]);</p><p>&nbsp; &nbsp; //左节点</p><p>&nbsp; &nbsp; PreOrderTraverse($node[&#39;lChild&#39;]);</p><p>&nbsp; &nbsp; //右节点</p><p>&nbsp; &nbsp; PreOrderTraverse($node[&#39;rChild&#39;]);</p><p>}</p><p>[/code]</p><p><br/></p><p>遍历算法二：中序遍历二叉树</p><p>[code]</p><p>&lt;?php</p><p>//中序遍历二叉树算法</p><p>echo &#39;中序遍历二叉树算法：&#39;;</p><p>inOrderTraverse($arr);</p><p>echo &#39;&lt;Br&gt;&#39;;</p><p>function inOrderTraverse($node){</p><p>&nbsp; &nbsp; if(empty($node)){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; return;</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; //左节点</p><p>&nbsp; &nbsp; inOrderTraverse($node[&#39;lChild&#39;]);</p><p>&nbsp; &nbsp; //输出值</p><p>&nbsp; &nbsp; print_r($node[&#39;data&#39;]);</p><p>&nbsp; &nbsp; //右节点</p><p>&nbsp; &nbsp; inOrderTraverse($node[&#39;rChild&#39;]);</p><p>}</p><p>[/code]</p><p><br/></p><p style="white-space: normal;">遍历算法三：后序遍历二叉树</p><p style="white-space: normal;">[code]</p><p style="white-space: normal;">&lt;?php</p><p>//后序遍历二叉树算法</p><p>echo &#39;后序遍历二叉树算法：&#39;;</p><p>postOrderTraverse($arr);</p><p>echo &#39;&lt;Br&gt;&#39;;</p><p>function postOrderTraverse($node){</p><p>&nbsp; &nbsp; if(empty($node)){</p><p>&nbsp; &nbsp; &nbsp; &nbsp; return;</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; //左节点</p><p>&nbsp; &nbsp; postOrderTraverse($node[&#39;lChild&#39;]);</p><p>&nbsp; &nbsp; //右节点</p><p>&nbsp; &nbsp; postOrderTraverse($node[&#39;rChild&#39;]);</p><p>&nbsp; &nbsp; //输出值</p><p>&nbsp; &nbsp; print_r($node[&#39;data&#39;]);</p><p>}</p><p style="white-space: normal;">[/code]</p>', 1404890917, 1, 0, 0),
(64, 6, '李轩Lane', '2014书目，自勉！', '2014年看过的书，一方面自己给自己鼓劲，一方面给大家推荐推荐。其实就是记录一下2014年看了那些书，而已。', '2014年看过的书，一方面自己给自己鼓劲，一方面给大家推荐推荐', '2014年看过的书，一方面自己给自己鼓劲，一方面给大家推荐推荐。其实就是记录一下2014年看了那些书，而已。', '2014年看过的书，一方面自己给自己鼓劲，一方面给大家推荐推荐', '书', 95, '<p>这篇其实就是记录一下2014年我所看书的list。</p><p>看到记录的增加，脑袋的知识增加，满满的成就感，很开心。</p><p><br/></p><p>3月13：《高性能Mysql》 没看完，看了30%</p><p>4月15-5月4日：《大话设计模式》</p><p>4月：《Mysql必知必会》</p><p>5月：《Redis入门指南》</p><p>5月：《Python简明教程》</p><p>5月：《PHP核心技术与最佳实践》 这本书推荐一下</p><p>6月：《MongoDB权威指南》 没看完，看了20%</p><p>6月：《PHP精粹》</p><p>6月：《莽荒记》 我能说我喜欢看修仙/玄幻的小说么，我能说我喜欢大番茄么</p><p>6月25日 - 7月18日：《大话数据结构》</p><p>7月13日：《C程序语言设计》 被誉为C的圣经的一本书，因为我打算重新温习一下C了。电子版看了一点点，手机看不舒服，明天去问公司借本。</p><p>7月17日：《高性能程序员的修炼》</p><p><br/></p><p>很多时候都是同时看几本，公司看一本，家里看一本。路上看小说。。。今年目标还有C++和JAVA。尽管是PHP Developer。</p><p><br/></p>', 1405577446, 0, 0, 0),
(65, 1, '李轩Lane', '微信PHP快速开发框架LaneWeChat', '微信框架LaneWeChat，是微信PHP开发框架，经过中国联通、游戏公司等多家公司使用的微信PHP框架，轻量、高效。完美的封装了PHP微信开发的功能点，只需要调用封装好的函数，5分钟上手，10分钟精通PHP微信开发。LaneWeChat微信开发框架为全国大中小企业提供了接入微信的好机会。', '微信框架_微信PHP框架_微信开发框架_LaneWeChat', '微信框架LaneWeChat，是微信PHP开发框架，经过中国联通、游戏公司等多家公司使用的微信PHP框架，轻量、高效。完美的封装了PHP微信开发的功能点，只需要调用封装好的函数，5分钟上手，10分钟精通PHP微信开发。LaneWeChat微信开发框架为全国大中小企业提供了接入微信的好机会。', '微信框架,微信PHP框架,微信开发框架,LaneWeChat', 'PHP|微信|框架', 395, '<p>框架名称：LaneWeChat &nbsp; 微信开发框架PHP</p><p><br/></p><p>框架版本：1.0</p><p><br/></p><p>框架简介：这是一个为快速开发微信应用而生的PHP框架。将微信的开发者功能根据文档进行了封装。为了快速开发的目的，开发者完全不需要要知道具体是如何实现的，只需要简单的调用方法即可。微信框架LaneWeChat，经过中国联通、奇虎360等多家公司使用的微信PHP框架，轻量、高效。完美的封装了PHP微信开发的功能点，只需要调用封装好的函数，5分钟上手，10分钟精通PHP微信开发。LaneWeChat微信开发框架为全国大中小企业提供了接入微信的好机会。</p><p><br/></p><p>开发语言：PHP</p><p><br/></p><p>版本要求：原则PHP5.3以上</p><p><br/></p><p>版本规避：若版本低于PHP5.3，则删除本框架所有页面开头namespace一行即可。</p><p><br/></p><p>命名空间：本框架的命名空间均为LaneWeChat开头。</p><p><br/></p><p>下载地址：https://github.com/lixuancn/LaneWeChat/archive/master.zip</p><p><br/></p><p>GitHub：https://github.com/lixuancn/LaneWeChat</p><p><br/></p><p>目前还没有微信支付这些，只有微信公众账号的相关功能，希望大家闲暇时间也可以贡献代码。</p><p><br/></p><p><br/></p><p>Developer Blog：http://www.lanecn.com</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p>文档目录：</p><p><br/></p><p>&nbsp; &nbsp; 1、常识普及。</p><p><br/></p><p>&nbsp; &nbsp; 2、如何安装。</p><p><br/></p><p>&nbsp; &nbsp; 3、初出茅庐。</p><p><br/></p><p>&nbsp; &nbsp; 4、流程分析。</p><p><br/></p><p>&nbsp; &nbsp; 5、牛刀小试。</p><p><br/></p><p>&nbsp; &nbsp; 6、函数详解。</p><p><br/></p><p>&nbsp; &nbsp; 7、实例示范。</p><p><br/></p><p><br/></p><p>常识普及：</p><p><br/></p><p>一、微信公众账号分两种，一种是订阅号，一种是服务号。</p><p><br/></p><p>&nbsp; &nbsp; 1、订阅号是被动响应用户消息功能，并且每天推送一条消息。</p><p><br/></p><p>&nbsp; &nbsp; 2、服务号是300元/每年认证，被动响应用户消息，主动给用户发送消息，自定义菜单按钮，网页授权等功能，并且每月推送一条消息。</p><p><br/></p><p>&nbsp; &nbsp; 3、订阅号适合消息类，新闻类应用，常常需要推送文章给用户的；服务号适合自助查询等。</p><p><br/></p><p>&nbsp; &nbsp; 4、订阅号被认证后也享用自定义菜单等功能，仍旧是300元/每年</p><p><br/></p><p><br/></p><p><br/></p><p>二、专业术语：</p><p><br/></p><p>&nbsp; &nbsp; 1、OpenId：微信服务器并不会告诉公众号用户的微信ID，即使是你的关注者也不行，为了解决开发中唯一标识的问题，微信使用了OpenId，所谓的OpenId，就是用户和微信公众号之间的一种唯一关系。一个用户在一个公众号面前，享用唯一的OpenId，不会和别人重复。换言之，同一个用户在另一个公众号面前，是拥有另一个OpenId的。再直白些就是$openId = md5(&#39;用户微信ID+公众号ID&#39;)</p><p><br/></p><p>&nbsp; &nbsp; 2、Access_Token：此项只有认证号的功能才会使用的到，Access_token是一个授权标识，即一个授权验证码，一个标识10分钟内有效，10分钟的有效期内公众号的多个关注者可以使用同一个Access_Token。在使用主动给指定用户发送消息、自定义菜单、用户管理和用户组管理等功能的时候，每次操作需要给微信服务器以参数的形式附带Access_token。</p><p><br/></p><p>&nbsp; &nbsp; 3、Access_Token网页版：本Access_Token网页版授权时会使用到，和2中的Access_Toekn是不同的东西，不过使用我们的LaneWeChat微信快速开发框架是不需要了解这些的。Access_Token网页版是说在用户打开你的公众号提供的网页的时候，你的网页需要获取用户的OpenId、昵称、头像等信息的时候授权用的。同时，本Access_Token网页版有两种用法，一种是打开网页后弹出一个授权框，让用户点击是否授权，界面像主流的开放平台授权界面（比如QQ登陆某网站，支付宝账号登陆某网站等）；另一种是不需要弹出授权框仍旧可以获取用户信息，用法可以在实例中看到。</p><p><br/></p><p><br/></p><p>如何安装：</p><p><br/></p><p>&nbsp; &nbsp; 1、本框架以代码包的插件形式放在项目的目录中即可。</p><p><br/></p><p>&nbsp; &nbsp; 2、配置项：打开根目录下的config.php，修改定义常量WECHAT_APPID，WECHAT_APPSECRET，WECHAT_URL。其中前两项可以在微信公众号官网的开发者页面中找到，而WECHAT_URL是你微信项目的URL，以http://开头</p><p><br/></p><p>&nbsp; &nbsp; 3、本框架的唯一入口为根目录下的wechat.php</p><p><br/></p><p>&nbsp; &nbsp; 4、首次使用时，请打开根目录下的wechat.php，注释掉20行，21行，并且打开注释第24行。</p><p><br/></p><p>&nbsp; &nbsp; 5、在微信开发者-填写服务器配置页面，填写URL为http://www.lanecn.com/wechat.php，保证该URL可以通过80端口正常访问（微信服务器目前只支持80端口），并且将Token填写为config.php中的WECHAT_TOKEN常量的内容（可以修改）。</p><p><br/></p><p>&nbsp; &nbsp; 6、微信服务器在第4步验证通过后，反向操作第4步，即注释掉第24行，打开注释第20行，21行。至此，安装配置完成。</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p>初出茅庐：</p><p><br/></p><p>&nbsp; &nbsp; 1、给你的微信公众号发送一条文本消息，比如hello world或者其他什么的。这个时候你应该会收到一条“收到文本”的服务器反馈的被动响应的消息。</p><p><br/></p><p>&nbsp; &nbsp; 2、这个时候你需要先为自己鼓掌。</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p>流程分析：</p><p><br/></p><p>&nbsp; &nbsp; 1、我们给微信服务器发送了一条“hello world”的文本消息。</p><p><br/></p><p>&nbsp; &nbsp; 2、微信服务器收到我们的消息后，查找该公众账号所配置的服务器信息中的URL（如何安装部分 - 第5步）。</p><p><br/></p><p>&nbsp; &nbsp; 3、微信服务器向第二步获取的URL发送请求，参数是微信服务器自己拼接过的XML格式。</p><p><br/></p><p>&nbsp; &nbsp; 4、根目录下的wechat.php，引入了我们的配置文件和所需的类后，进入了类WeChat的方法run()。该类位于core/wechat.lib.php。微信的XML数据此时已经被解析为数组，变量名为$request。</p><p><br/></p><p>&nbsp; &nbsp; 5、然后，我们进入了类WechatRequest的方法switchType()，根据不同的消息类型，给予不同的响应。比如用户发送文本消息和关注事件，给出的返回应该是不同的。当然，你要给出同样的提示也不能说是错的。</p><p><br/></p><p>&nbsp; &nbsp; 6、在第5步中的方法中，是一个switch，根据消息类型（此时是文本类型，微信服务器给我的是text）选择了一个处理文本消息的方法，类WechatRequest中的方法text()。该方法的功能是发送文本消息，文本内容是“收到文本”。</p><p><br/></p><p>&nbsp; &nbsp; 7、此时，我们return了一个数据返回给了上层调用，层层return，就到了我们根目录的下的唯一入口文件wechat.php，此时我们返回的数据被echo出来了。</p><p><br/></p><p>&nbsp; &nbsp; 8、微信服务器拿到了输出的数据，微信服务器进行分析和处理，将文本发送给了用户的微信客户端。我们就在手机上看到了微信输出的“收到文本”。</p><p><br/></p><p>&nbsp; &nbsp; 9、流程结束，这就是发送“hello world”，然后返回给用户“收到文本”。</p><p><br/></p><p><br/></p><p>牛刀小试：</p><p><br/></p><p>&nbsp; &nbsp; 1、打开core/wechatrequest.php文件，讲方法text()中的变量修改为$content = &#39;收到文本消息&#39;.$request[&#39;content&#39;];</p><p><br/></p><p>&nbsp; &nbsp; 2、保存并且上传到你的服务器。</p><p><br/></p><p>&nbsp; &nbsp; 3、在微信中打开你的公众号，输入文本消息“hello world”。见证奇迹的时刻到了。这个时候你的手机微信客户端中现实的是“收到文本消息hello world”。</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p>函数详解：</p><p><br/></p><p>&nbsp; &nbsp; 一、被动给用户发送消息。</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1、类简介：用户输入文本、图片、语音、音乐、视频等消息，以及关注、取消关注，上报地理位置等事件后，服务器被动给出应答。</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2、使用命名空间：use LaneWeChat\\Core\\ResponsePassive;</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3、参数： &nbsp;$fromusername = &quot;谁发给你的？（用户的openId）&quot; &nbsp;在变量$request[&#39;fromusername&#39;]中</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$tousername = &quot;你的公众号Id&quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在变量$require[&#39;tousername&#39;]中</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$mediaId = &quot;通过上传多媒体文件，得到的id。&quot;;</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 4、发送文本</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResponsePassive::text($fromusername, $tousername, &#39;文本消息内容&#39;);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 5、发送图片</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResponsePassive::image($fromusername, $tousername, $mediaId);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 6、发送语音</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResponsePassive::voice($fromusername, $tousername, $mediaId);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 7、发送视频</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResponsePassive::video($fromusername, $tousername, $mediaId, &#39;视频标题&#39;, &#39;视频描述&#39;);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 8、发送音乐</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResponsePassive::music($fromusername, $tousername, &#39;音乐标题&#39;, &#39;音乐描述&#39;, &#39;音乐链接&#39;, &#39;高质量音乐链接，WIFI环境优先使用该链接播放音乐&#39;, &#39;缩略图的媒体id，通过上传多媒体文件，得到的id&#39;);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 9、发送图文</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1）创建图文消息内容</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $tuwenList = array();</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $tuwenList[] = array(&#39;title&#39;=&gt;&#39;标题1&#39;, &#39;description&#39;=&gt;&#39;描述1&#39;, &#39;pic_url&#39;=&gt;&#39;图片URL1&#39;, &#39;url&#39;=&gt;&#39;点击跳转URL1&#39;);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $tuwenList[] = array(&#39;title&#39;=&gt;&#39;标题2&#39;, &#39;description&#39;=&gt;&#39;描述2&#39;, &#39;pic_url&#39;=&gt;&#39;图片URL2&#39;, &#39;url&#39;=&gt;&#39;点击跳转URL2&#39;);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2）构建图文消息格式</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $itemList = array();</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach($tuwenList as $tuwen){</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $itemList[] = ResponsePassive::newsItem($tuwen[&#39;title&#39;], $tuwen[&#39;description&#39;], $tuwen[&#39;pic_url&#39;], $tuwen[&#39;url&#39;]);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3）发送图文消息</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResponsePassive::news($fromusername, $tousername, $itemList);</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p>二、AccessToken授权。</p><p><br/></p><p>&nbsp; &nbsp; 1、类简介：除了被动相应用户之外，在主动给用户发送消息，用户组管理等高级操作，是需要AccessToken授权的，我们调用一个URL给微信服务器，微信服务器会返回给我们一个散列字符串，在高级操作的时候需要将此串以参数的形式发送。散列字符串10分钟内有效，过期需要重新获取，获取新的后之前的全部失效。</p><p><br/></p><p>&nbsp; &nbsp; 2、使用命名空间：use LaneWeChat\\Core\\AccessToken;</p><p><br/></p><p>&nbsp; &nbsp; 3、参数：无</p><p><br/></p><p>&nbsp; &nbsp; 4、获取AccessToken</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; AccessToken::getAccessToken(); 该调用会返回微信服务器散列后的AccessToken字符串。</p><p><br/></p><p>&nbsp; &nbsp; 5、温馨提示</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果暂且用不到此功能，请跳过。最后来看这里！</p><p><br/></p><p>&nbsp; &nbsp; 6、功能补充</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 有一个地方需要用户自行完善，根据介绍我们已经知道了，获取AccessToken只有10分钟的有效期，过期需要重新获取。因此，我们需要存储这个AccessToken。</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 由于大家的存储方式各不相同，有Mysql的，有Redis的，有MongoDB的，还有Session的。所以这里我讲存储和读取给留空了。</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 流程：AccessToken类，public方法只有一个，就是getAccessToken()。这个方法会调用一个私有方法_checkAccessToken()来检测AccessToken是否存在并且是否过期，如果不存在或过期，则调用私有方法_getAccessToken()</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 完善步骤：</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1）、打开core/accesstoken.lib.php文件。</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2）、私有方法_getAccessToken()的倒数第二行（return是倒数第一行），在这个地方，请讲变量$accessTokenJson存储起来，变量$accessTokenJson是一个字符串。</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3）、私有方法_checkAccessToken()的第一行就是读取操作（有一行伪代码$accessToken = YourDatabase::get(&#39;access_token&#39;);），将刚才第二步的存储的东西给读出来，并且赋值给$accessToken。</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 4）、在第二步的存储，第三部的读取的时候，请不要修改数据，仅仅完善一个读和存的操作就可以了。</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p>三、主动给用户发送消息。<br/></p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1、类简介：用户输入文本、图片、语音、音乐、视频等消息，以及关注、取消关注，上报地理位置等事件后，服务器被动给出应答。</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2、使用命名空间：use LaneWeChat\\Core\\ResponsePassive;</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3、参数 &nbsp;$tousername = &quot;你的公众号Id&quot;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在变量$require[&#39;tousername&#39;]中</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $mediaId = &quot;通过上传多媒体文件，得到的id。&quot;;</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 4、发送文本内容</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; ResponseInitiative::text($tousername, &#39;文本消息内容&#39;);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 5、发送图片</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; ResponseInitiative::image($tousername, $mediaId);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 6、发送语音</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; ResponseInitiative::voice($tousername, $mediaId);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 7、发送视频</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; ResponseInitiative::video($tousername, $mediaId, &#39;视频描述&#39;, &#39;视频标题&#39;);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 8、发送地理位置</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; ResponseInitiative::music($tousername, &#39;音乐标题&#39;, &#39;音乐描述&#39;, &#39;音乐链接&#39;, &#39;高质量音乐链接，WIFI环境优先使用该链接播放音乐&#39;, &#39;缩略图的媒体id，通过上传多媒体文件，得到的id&#39;);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 9、发送图文消息</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1）创建图文消息内容</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $tuwenList = array();</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $tuwenList[] = array(&#39;title&#39;=&gt;&#39;标题1&#39;, &#39;description&#39;=&gt;&#39;描述1&#39;, &#39;pic_url&#39;=&gt;&#39;图片URL1&#39;, &#39;url&#39;=&gt;&#39;点击跳转URL1&#39;);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $tuwenList[] = array(&#39;title&#39;=&gt;&#39;标题2&#39;, &#39;description&#39;=&gt;&#39;描述2&#39;, &#39;pic_url&#39;=&gt;&#39;图片URL2&#39;, &#39;url&#39;=&gt;&#39;点击跳转URL2&#39;);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2）构建图文消息格式</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $itemList = array();</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach($tuwenList as $tuwen){</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $itemList[] = ResponseInitiative::newsItem($tuwen[&#39;title&#39;], $tuwen[&#39;description&#39;], $tuwen[&#39;pic_url&#39;], $tuwen[&#39;url&#39;]);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3）发送图文消息</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResponseInitiative::news($tousername, $itemList);</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p>四、用户及用户组管理。</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1、类简介：获取粉丝列表，创建\\修改用户组，讲用户添加\\移除到用户组。</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2、使用命名空间：use LaneWeChat\\Core\\UserManage;</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3、参数 &nbsp;$openId = &#39;用户和微信公众号的唯一ID&#39;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在变量$require[&#39;openid&#39;]中</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $mediaId = &quot;通过上传多媒体文件，得到的id。&quot;;</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $groupId = &#39;分组ID&#39;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在添加新分组、获取分组列表的时候可以得到</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 4、分组管理 - 创建分组</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UserManage::createGroup(&#39;分组名&#39;);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 5、分组管理 - //获取分组列表</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UserManage::getGroupList();</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 6、分组管理 - 查询用户所在分组</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UserManage::getGroupByOpenId($openId);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 7、分组管理 - 修改分组名</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UserManage::editGroupName($groupId, &#39;新的组名&#39;);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 8、分组管理 - 移动用户分组</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UserManage::editUserGroup($openId, $groupId);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 9、用户管理 - 获取用户基本信息</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UserManage::getUserInfo($openId);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 10、用户管理 - 获取关注者列表</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UserManage::getFansList($next_openId=&#39;&#39;);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 11、用户管理 - 获取网络状态</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UserManage::getNetworkState();</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p>五、网页授权。</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1、类简介：在网页中获取来访用户的数据。</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2、使用命名空间：use LaneWeChat\\Core\\WeChatOAuth;</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3、参数 &nbsp;$openId = &#39;用户和微信公众号的唯一ID&#39;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在变量$require[&#39;openid&#39;]中</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $mediaId = &quot;通过上传多媒体文件，得到的id。&quot;;</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $groupId = &#39;分组ID&#39;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在添加新分组、获取分组列表的时候可以得到</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 4、获取CODE。</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 参数：$scope：snsapi_base不弹出授权页面，只能获得OpenId;snsapi_userinfo弹出授权页面，可以获得所有信息</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 参数：$redirect_uri：将会跳转到redirect_uri/?code=CODE&amp;state=STATE 通过GET方式获取code和state。获取CODE时，发送请求和参数给微信服务器，微信服务器会处理后将跳转到本参数指定的URL页面</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WeChatOAuth::getCode($redirect_uri, $state=1, $scope=&#39;snsapi_base&#39;);</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 5、通过code换取网页授权access_token（access_token网页版）。首先请注意，这里通过code换取的网页授权access_token,与基础支持中的access_token不同。公众号可通过下述接口来获取网页授权access_token。如果网页授权的作用域为snsapi_base，则本步骤中获取到网页授权access_token的同时，也获取到了openid，snsapi_base式的网页授权流程即到此为止。</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 参数：$code getCode()获取的code参数。$code = $_GET[&#39;code&#39;];</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WeChatOAuth::getAccessTokenAndOpenId($code);</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p>实例示范：</p><p><br/></p><p>&nbsp; &nbsp; 1、通过网页授权获得用户信息</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 场景：用户点击了我的自定义菜单，或者我发送的文本消息中包含一个URL，用户打开了我的微信公众号的网页版，我需要获取用户的信息。</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 代码：</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &lt;?php</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use LaneWeChat\\Core\\WeChatOAuth;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use LaneWeChat\\Core\\UserManage;</p><p><br/></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //第一步，获取CODE</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WeChatOAuth::getCode(&#39;http://www.lanecn.com/index.php&#39;, 1, &#39;snsapi_base&#39;);</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //此时页面跳转到了http://www.lanecn.com/index.php，code和state在GET参数中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $code = $_GET[&#39;code&#39;];</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //第二步，获取access_token网页版</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $openId = WeChatOAuth::getAccessTokenAndOpenId($code);</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //第三步，获取用户信息</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $userInfo = UserManage::getUserInfo($openId[&#39;openid&#39;]);</p><p>&nbsp; &nbsp; &nbsp; &nbsp; ?&gt;</p><p><br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;2、更多实例正在补充。<br/></p>', 1407137982, 6, 0, 1);

-- --------------------------------------------------------

--
-- 表的结构 `info_comment`
--

CREATE TABLE IF NOT EXISTS `info_comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '评论ID',
  `cid` int(11) NOT NULL COMMENT '所属评论',
  `aid` int(11) NOT NULL COMMENT '所属文章ID',
  `mid` int(11) NOT NULL COMMENT '所属分类',
  `content` text NOT NULL COMMENT '评论内容',
  `nickname` varchar(50) NOT NULL COMMENT '用户的昵称',
  `email` varchar(100) NOT NULL COMMENT '邮箱地址',
  `website` varchar(200) NOT NULL COMMENT '个人主页地址',
  `ctime` int(11) NOT NULL COMMENT '创建时间',
  `good_num` int(11) NOT NULL COMMENT '被赞的次数',
  `bad_num` int(11) NOT NULL COMMENT '被拍砖的次数',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=91 ;

--
-- 转存表中的数据 `info_comment`
--

INSERT INTO `info_comment` (`id`, `cid`, `aid`, `mid`, `content`, `nickname`, `email`, `website`, `ctime`, `good_num`, `bad_num`) VALUES
(5, 0, 3, 1, '学习了', 'Guofeng', '', '', 1392015649, 0, 0),
(6, 0, 3, 1, '测试过了，可以用', 'Guofeng', '', '', 1392797044, 0, 0),
(7, 0, 6, 5, '学习了', 'lin', '', '', 1392974881, 0, 0),
(8, 0, 7, 1, '正好需要，多谢', 'quyang', '', '', 1394169504, 0, 0),
(9, 0, 8, 1, '这也太闹心了。。平时开发完全不会这么写。', 'Zhang', '', '', 1394255469, 0, 0),
(10, 0, 11, 1, '学习了。一个很基础的MVC框架。对于我这种想知道框架是如何开发的人来说太有帮助了', 'Marina', '', '', 1395456406, 0, 0),
(11, 0, 11, 1, '不错,很赞', 'sssi', '', '', 1395830196, 0, 0),
(12, 0, 11, 1, '不错，下载来搭建一个博客，对搜索引擎是很友好。', 'seo爱好者', '', '', 1396110129, 0, 0),
(13, 0, 11, 1, 'fucking test', 'test', 'fucking', 'www.fucking.com', 1396512685, 0, 0),
(14, 0, 11, 1, '不懂,佩服', '小白', '', '', 1397187830, 0, 0),
(15, 0, 11, 1, '作为外语专业毕业的软件小白,自学了html后(css什么的还不懂),开始在自学日语版的php(身边没中文版资料),这么多代码,看的头昏,看到博主这么厉害,真心佩服.会常来看,在网上也找不到php基础知识网站,还有点迷茫,总想早点学会,却有时候看的力不从心,因为会涉及日语版的专业单词,会涉及完全不懂的编程知识,还涉及不擅长的英语.真心辛苦,可是好想学会php啊!\r\n楼主自己建立程序,我很膜拜,是激励我自己进步的榜样!\r\n真心希望越建越好!', '小白', '', '', 1397188842, 0, 0),
(16, 0, 11, 1, 'PS:我从csdn看到链接来的,是csdn里面那一小撮啥都不懂的小白,呵呵,其实我猜应该会有好多对软件感兴趣的非专业的朋友在里面.我都不好意思在csdn发言,所以甚至没注册ID.好希望有一天能像你们一样厉害!', '小白', '', '', 1397189083, 0, 0),
(17, 0, 8, 1, '第二题我验证的结果是-2147483648，改成32次方才是0呀！', 'Kanye', 'tmtonykanye@163.com', '', 1398391240, 0, 0),
(18, 0, 8, 1, ' Kanye.抱歉。打错了。是32次方。多谢。', 'Lane', 'lixuan868686@163.com', 'http://www.lanecn.com', 1398440414, 0, 0),
(19, 0, 11, 1, '已下载，学习中', 'CoCo', '', '', 1399199215, 0, 0),
(20, 0, 11, 1, '超级赞', '超级赞', '', '', 1399336095, 0, 0),
(21, 0, 44, 10, '不错，很赞哦', 'Si', '', 'http://www.lanecn.com/article/main/aid-45', 1400035430, 0, 0),
(22, 0, 46, 10, '正在学习redis。谢谢', '哦哦哦', '', '', 1400070412, 0, 0),
(23, 0, 48, 10, 'sort果然是redis最复杂的逻辑之一', 'Marina', '', '', 1400425183, 0, 0),
(26, 0, 51, 1, '很棒。学习了', '菜鸟', '', '', 1400555724, 0, 0),
(29, 0, 51, 1, '很好。', 'Si', '', '', 1400633866, 0, 0),
(77, 22, 46, 10, 'good', 'ss', '', '', 1405300783, 0, 0),
(78, 0, 64, 6, '很棒，我也打算看一遍', 'smile', '', '', 1405677082, 0, 0),
(87, 0, 65, 1, '很棒', 'aa', '', '', 1407394966, 0, 0),
(88, 0, 65, 1, '很棒，已经下载', 'love', '', '', 1407395001, 0, 0),
(89, 0, 65, 1, '正好需要', 'xy', '', '', 1407406248, 0, 0),
(90, 0, 65, 1, 'get', 'Chen', '', '', 1407460666, 0, 0),
(81, 0, 64, 6, '大轩神，有点屌！', 'Coder黄老邪', 'Coder@laoxieit.com', 'http://www.laoxieit.com', 1406103759, 0, 0),
(82, 81, 64, 6, '一般叼一般叼', 'Lane', 'lixuan868686@163.com', 'http://www.lanecn.com', 1406165137, 0, 0);

-- --------------------------------------------------------

--
-- 表的结构 `info_friend_link`
--

CREATE TABLE IF NOT EXISTS `info_friend_link` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL COMMENT '站名',
  `url` varchar(100) NOT NULL COMMENT '链接',
  `nofollow` tinyint(4) NOT NULL COMMENT '1是添加nofollow，0不添加',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COMMENT='友情链接' AUTO_INCREMENT=9 ;

--
-- 转存表中的数据 `info_friend_link`
--

INSERT INTO `info_friend_link` (`id`, `name`, `url`, `nofollow`) VALUES
(1, 'PHP', 'http://www.php.net', 1),
(2, 'Mysql', 'http://www.mysql.com', 1),
(7, 'php技术博客', 'http://www.phper163.com', 0),
(6, 'PHP爱好者', 'http://www.joyphper.net/', 0),
(8, 'PHP程序员', 'http://www.php230.com', 0);

-- --------------------------------------------------------

--
-- 表的结构 `info_menu`
--

CREATE TABLE IF NOT EXISTS `info_menu` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL COMMENT '分类名',
  `seo_title` varchar(100) NOT NULL COMMENT 'SEO - title',
  `seo_description` varchar(500) NOT NULL COMMENT 'SEO - description',
  `seo_keywords` varchar(200) NOT NULL COMMENT 'SEO - 关键词',
  `in_out` tinyint(4) NOT NULL COMMENT '指向站内(1)或站外(2)',
  `pid` int(11) NOT NULL COMMENT '父类ID。0是顶级分类',
  `url` varchar(100) NOT NULL COMMENT '出站链接地址，in_out为2是生效',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COMMENT='菜单分类' AUTO_INCREMENT=12 ;

--
-- 转存表中的数据 `info_menu`
--

INSERT INTO `info_menu` (`id`, `name`, `seo_title`, `seo_description`, `seo_keywords`, `in_out`, `pid`, `url`) VALUES
(1, 'PHP', 'php_php博客_php研究', 'PHP的文章，资讯，和技术研究分享。', 'php,php博客,php研究', 1, 0, ''),
(4, 'Mysql', 'Mysql_Mysql博客_Mysql分享', 'MYSQL的文章，资讯，和技术研究分享。', 'Mysql,Mysql博客,Mysql分享', 1, 0, ''),
(5, 'Linux', 'Linux分享_Linux技术_Linux讨论', 'Linux分享模块，提供Linux技术和Linux讨论', 'Linux分享,Linux技术,Linux讨论', 1, 0, ''),
(6, '个人随笔', 'Lane_LiXuan_BLog', '个人随笔，杂记文章，用自己的博客，写自己的故事。', 'Lane,LiXuan,BLog', 1, 0, ''),
(7, '其他软件', '其他软件的使用与问题解决', '其他软件的使用与问题解决', '其他软件的使用与问题解决', 1, 0, ''),
(8, '灵魂思想', '代码核心思想_写代码的核心思想_代码的思想灵魂', '代码的核心思想是什么？语言只是工具，真正的核心是数据结构，算法，设计模式。鄙人以为，这些是写代码的真正的灵魂和思想。', '代码核心思想,写代码的核心思想,代码的思想灵魂', 1, 0, ''),
(9, 'Python', 'Python_Python基础教程_Python核心编程', 'Python是解释型面向对象脚本。本博客记录博主通过Python基础教程开始，不断的向Python核心编程攀登。记录了博主的Python学习之路。', 'Python,Python基础教程,Python核心编程', 1, 0, ''),
(10, 'Redis', 'redis命令_redis使用_redis集群', 'redis命令详解和redis使用，redis集群部署方式将在本博客逐一解答作为最知名的NOSQL，redis使用非常广泛，redis集群部署方案解决亿万访问量和高并发。redis命令简单，redis使用方便快捷，redis集群高效安全，大有取代传统关系数据库之势。', 'redis命令,redis使用,redis集群', 1, 0, ''),
(11, '架构', '网站架构_高性能架构_大型架构', '架构分类的文章内容包括网站架构，高性能架构和大型架构方案，提高响应速度和用户体验。在大型项目中一个良好的架构决定了项目的成败。', '网站架构,高性能架构,大型架构', 1, 0, '');

-- --------------------------------------------------------

--
-- 表的结构 `info_tag`
--

CREATE TABLE IF NOT EXISTS `info_tag` (
  `tag` varchar(50) NOT NULL COMMENT 'TAG内容',
  `num` int(11) NOT NULL COMMENT '出现次数',
  `id` int(11) NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COMMENT='TAG' AUTO_INCREMENT=92 ;

--
-- 转存表中的数据 `info_tag`
--

INSERT INTO `info_tag` (`tag`, `num`, `id`) VALUES
('PHP', 104, 1),
('刷投票', 1, 2),
('MYSQL', 6, 3),
('随机查询', 2, 4),
('Linux', 3, 5),
('LAMP', 3, 6),
('随机数', 3, 7),
('时间种子', 3, 8),
('面试', 2, 82),
('面试题', 6, 10),
('PHP面试题', 3, 11),
('笔试题', 3, 12),
('Ubuntu', 2, 13),
('Fedora', 4, 14),
('VirtualBox', 7, 15),
('vbox', 4, 16),
('XP', 3, 17),
('虚拟机', 3, 18),
('博客', 8, 19),
('框架', 13, 20),
('计数器', 4, 21),
('高性能', 4, 22),
('设计模式', 54, 26),
('投资', 3, 24),
('回报', 3, 25),
('灵魂思想', 1, 27),
('简单工厂模式', 3, 28),
('策略模式', 2, 29),
('单一原则', 2, 30),
('开放-封闭原则', 2, 31),
('依赖倒转原则', 1, 32),
('装饰模式', 1, 33),
('代理模式', 2, 34),
('工厂方法', 3, 35),
('原型模式', 3, 36),
('模板方法模式', 2, 37),
('迪米特法则', 1, 38),
('外观模式', 1, 39),
('建造者模式', 4, 40),
('观察者模式', 1, 41),
('抽象工厂模式', 5, 42),
('状态模式', 1, 43),
('适配器模式', 2, 44),
('备忘录模式', 3, 45),
('组合模式', 2, 46),
('迭代器模式', 3, 47),
('单例模式', 1, 48),
('桥接模式', 2, 49),
('命令模式', 1, 50),
('职责链模式', 1, 51),
('中介模式', 1, 52),
('享元模式', 1, 53),
('解释器模式', 1, 54),
('访问者模式', 1, 55),
('Python', 2, 56),
('Python基础', 2, 57),
('Python示例', 2, 58),
('redis', 18, 59),
('redis数据类型', 5, 60),
('redis数据命令', 5, 61),
('事务', 2, 62),
('redis事务', 2, 63),
('redis watch', 2, 64),
('生存周期', 1, 65),
('生存时间', 1, 66),
('排序', 1, 67),
('redis SORT', 1, 68),
('队列', 1, 69),
('栈', 1, 70),
('聊天', 1, 71),
('广播', 1, 72),
('Mamcache', 2, 73),
('分布式', 3, 74),
('架构', 1, 75),
('Hash', 4, 76),
('数据库', 3, 77),
('管道', 3, 78),
('命名空间', 3, 79),
('XHProf', 3, 80),
('Memcache', 1, 81),
('百度', 2, 83),
('', 2, 84),
('test', 4, 85),
('后缀', 6, 86),
('中缀', 6, 87),
('二叉树', 5, 88),
('算法', 5, 89),
('书', 2, 90),
('微信', 5, 91);
